function featureBasedImageRegistrationParentHandle = featureBasedImageRegistration(varargin)
% Interactive UI for performing feature-based image registration using a
% detect/extract/match workflow with the Computer Vision System Toolbox.
%
% SYNTAX:
% featureBasedImageRegistration
%     Creates a new instance of the Feature-Based Image Registration app
%     with default images. (New images can be loaded from the menubar.)
%
% featureBasedImageRegistration(fixed, moving)
%     Creates a new instance of the Feature-Based Image Registration app.
%
% featureBasedImageRegistration(fixed)
%     Creates a new instance of the Feature-Based Image Registration app.
%     In this case, moving = fixed;this can be useful for visualizing
%     features.
%
% featureBasedImageRegistrationParentHandle = featureBasedImageRegistration(...)
%     Also creates a handle to the tool
%
% See also: segmentImage, imageMorphology, cascadeTrainer, ImageRegistrationApp, 
% circleFinder, customGray, ImageAdjuster, ExploreRGB, textRecognizer
%
% Brett Shoelson, PhD
% brett.shoelson@mathworks.com

% Copyright The MathWorks, Inc. 2015.
%
% Datestamp: 1/28/2014
%
% 8/27/14 Modified for R2014b readiness;tweaks to layout, 
% handlevisibility, etc.
% 1/12/15 Layout changes, general tweaks. Revamp of linked-property
% handling.
% 2/4/2016 Modified to output the tform to the base workspace.
% 11/09/2020 Added 'softenValue' to deal, fixed spacing issues.

narginchk(0, 2);
singleton = true;%Change this to true to dis-allow multiple instances

[allDefaults, allUIs, buttonGroupChangedFcn, bgColor, colors, defaultFontsize, ...
	descriptors1, descriptors2, detectString1, detectString2, ...
	displayString, extractString1, extractString2, ...
	features1, features2, fixed, fixedName, highlightColor, ...
	index_pairs, initialWarnState, inliers1, inliers2, ...
	matched1, matched2, matchString, moving, movingName, preBRISK, ...
	registered, registerString, softenValue, tform, thenString, ...
	validPoints1, validPoints2] ...
	= deal([]);

flickerFrequency = 1;%Hz
[wav, freq] = audioread('notify.wav');
notification = audioplayer(wav, freq);
%
initializeCVTool(varargin{:})
featureBasedImageRegistrationParent = figure('numbertitle', 'off', ...
	'Units', 'normalized', ...
	'Tag', 'featureBasedImageRegistrationParent', ...
	'Name', 'featureBasedImageRegistration', ...
	'NumberTitle', 'off', ...
	'Visible', 'off', ...
	'Color', bgColor, ...
	'WindowStyle', 'normal', ...
	'pos', [0 1/30 1 0.9], ...
	'MenuBar', 'none', ...
	'ToolBar', 'auto', ...
	'Resize', 'on', ...
	'closerequestfcn', @resetAndClose);
rectPos1 = [1 1 size(fixed, 2)-1 size(fixed, 1)-1];
rectPos2 = [1 1 size(moving, 2)-1 size(moving, 1)-1];

featureBasedImageRegistrationParentHandle = featureBasedImageRegistrationParent;
set(featureBasedImageRegistrationParent, ...
	'defaultuicontrolinterruptible', 'on', ...
	'defaultuicontrolbusyaction', 'cancel')

% MENU/TOOL Bar
tbar = uitoolbar(featureBasedImageRegistrationParent);
tmp = im2double(imread('file_open.png'));
tmp(tmp == 0) = NaN;
uitoggletool(tbar, ...
	'CData', tmp, ...
	'oncallback', @GetNewFile, ...
	'offcallback', '', ...
	'Tooltipstring', 'Load new image(s)', ...
	'Tag', 'loadImageTool');
tmp = imread('exportIcon.png');
uitoggletool(tbar, ...
	'CData', tmp, ...
	'oncallback', @exportResults, ...
	'offcallback', '', ...
	'Tooltipstring', 'Export results', ...
	'Tag', 'exportResults');
tmp = imread('DefaultD2.png');
uitoggletool(tbar, ...
	'CData', tmp, ...
	'tag', 'Defaults', ...
	'separator', 'on', ...
	'oncallback', @resetDefaults, ...
	'Tooltipstring', 'Resets all uicontrols to default values.');
tmp = imread('tooltipIcon2.png');
toggleTooltipButton = uitoggletool(tbar, ...
	'CData', tmp, ...
	'tag', 'toggleTooltips', ...
	'separator', 'off', ...
	'oncallback', @toggleTooltipCB, ...
	'Tooltipstring', 'Toggle tooltips on or off.');
soundOn = true;
tmp = imread('soundIcon.png');
soundOnOffButton = uitoggletool(tbar, ...
	'CData', tmp, ...
	'tag', 'toggleTooltips', ...
	'separator', 'off', ...
	'oncallback', @toggleSound, ...
	'Tooltipstring', 'Toggle sound on or off.');
ico = imread('swapIcon.png');
ico = imresize(ico, size(tmp, 2)/size(ico, 2), 'bicubic');
uitoggletool(tbar, ...
	'CData', ico, ...
	'oncallback', @swapImages, ...
	'offcallback', '', ...
	'separator', 'on', ...
	'Tooltipstring', 'Swap Fixed/Moving images');
tmp = imread('logo.png');
uitoggletool(tbar, ...
	'CData', tmp, ...
	'oncallback', @acknowledgements, ...
	'offcallback', '', ...
	'separator', 'on', ...
	'Tooltipstring', 'Credits', ...
	'Tag', 'Examples');

% ANNOTATION: Click to view/ExpandAxes
panelHeight = 0.025;
a = annotation('textbox', [0.455 0.99-panelHeight 0.535 panelHeight], ...
	'string', 'CLICK ON ANY IMAGE TO VIEW IT IN A LARGER WINDOW.', ...
	'color', highlightColor, ...
	'horizontalalignment', 'c', ...
	'fontweight', 'b', ...
	'fontsize', defaultFontsize, ...
	'backgroundcolor', bgColor*1.2, ...
	'verticalalignment', 'middle');

% MAIN WORKFLOW PANELS
% SET UP 5 PANELS:
PG = 0.0175;%GAP
% HEIGHTS of 1-4;5 adjusts automatically:
PH = [0.275 0.125 0.125 0.12];
PH = [PH 1-(sum(PH)+(numel(PH)+2)*PG)];
% BOTTOMS
PB = [sum(PH(2:5))+5*PG sum(PH(3:5))+4*PG sum(PH(4:5))+3*PG PH(5)+2*PG PG];

% DEMSR = Detect/Extract/Match/Show/Register (Panels)
panelHeight = 0.9;
DEMSRColor = [0.49737 0.56165 0.64737];
% PARENT PANEL for Detect/Extract/Match/Show/Register
registerAlignPanel = uipanel(featureBasedImageRegistrationParent, ...
	'units', 'normalized', ...
	'position', [0.005 0.99-panelHeight 0.44 panelHeight], ...
	'backgroundcolor', DEMSRColor);
parent = registerAlignPanel;
displayArrowsAx = axes('parent', parent, ...
	'units', 'normalized', ...
	'position', [0.005 PG 0.04 1-2*PG], ...0.005
	'color', get(parent, 'backgroundcolor'));
image(imread('DetectExtractMatchVisualizeRegister.png'), ...
	'parent', displayArrowsAx)
set(displayArrowsAx, 'visible', 'off')

% (FEATURE TYPE)
uipanel1 = uipanel('parent', registerAlignPanel, ...
	'Units', 'normalized', ...
	'Position', [0.055 PB(1) 0.93 PH(1)], ...
	'Tag', 'uipanel1', ...
	'Title', ' FEATURE TYPE AND OPTIONS FOR FEATURE DETECTION ', ...
	'TitlePosition', 'lefttop', ...
	'BorderType', 'etchedin', ...
	'BorderWidth', 1, ...
	'BackgroundColor', DEMSRColor, ...
	'ForegroundColor', highlightColor, ...
	'FontName', 'MS Sans Serif', ...
	'FontSize', defaultFontsize+1, ...
	'FontWeight', 'bold');
%
featureTypes = {'MSER', ...
	'SURF', ...
	'Harris (Corner)', ...
	'Min Eigen (Corner)', ...
	'FAST (Corner)', ...
	'BRISK (Corner)'};
detectionTypes = {'detectMSERFeatures', ...
	'detectSURFFeatures', ...
	'detectHarrisFeatures', ...
	'detectMinEigenFeatures', ...
	'detectFASTFeatures', ...
	'detectBRISKFeatures'};
tts = {...
	sprintf('Uses Maximally Stable Extremal Regions (MSER) algorithm to find regions.\n(DOC: detectMSERFeatures)'), ...
	sprintf('Implements the Speeded-Up Robust Features (SURF) algorithm to find blob features.\n(DOC: detectSURFFeatures)'), ...
	sprintf('Find corners using Harrisäº¡tephens algorithm.\n(DOC: detectHarrisFeatures)'), ...
	sprintf('Find corners using minimum eigenvalue algorithm.\n(DOC: detectMinEigenFeatures)'), ...
	sprintf('Find corners using the Features from Accelerated Segment Test (FAST) algorithm.\n(DOC: detectFASTFeatures)'), ...
	sprintf('Find multi-scale corner features using the Binary Robust Invariant Scalable Keypoints (BRISK) algorithm.')};
%
[objposBG, objdimBG] = distributeObjects(6, 0.975, 0.05, 0.015);
%
selectedFeatureType = 'MSER';
featureTypeBG = uibuttongroup('parent', uipanel1, ...
	'Units', 'normalized', ...
	'Position', [0.01 0.05 0.2 0.9025], ...
	'Tag', 'selectedFeatureType', ...%target
	'TitlePosition', 'lefttop', ...
	'BorderType', 'etchedin', ...
	'BorderWidth', 1, ...
	'BackgroundColor', DEMSRColor, ...
	'ForegroundColor', [1 1 1], ...
	'FontName', 'MS Sans Serif', ...
	'FontSize', defaultFontsize, ...
	buttonGroupChangedFcn, @updateUIControl);
FTPanels = gobjects(numel(featureTypes), 2);
FTButtons = gobjects(numel(featureTypes), 1);
dragROIString = {'If desired, adjust ROI parameter by dragging IMROIs on image axes.';
	'Note: ''hittest'' is enabled for the IMROIs;to expand the axes, please move the imroi and click directly on the image.'};
for ii = 1:numel(featureTypes)
	FTButtons(ii) = uicontrol(featureTypeBG, ...
		'style', 'radio', ...
		'units', 'normalized', ...
		'FontSize', defaultFontsize, ...
		'position', [0.025 objposBG(ii) 0.9 objdimBG], ...
		'string', featureTypes{ii}, ...
		'Tag', featureTypes{ii}, ...
		'backgroundcolor', DEMSRColor, ...
		'tooltipstring', tts{ii});
	for jj = 1:2 %Left and Right panels for Fixed and Moving images
		tmpgap = 0.02;
		[tmpobjpos, tmpobjdim] = distributeObjects(2, 0.225, 0.9875, tmpgap);
		FTPanels(ii, jj) = uipanel(uipanel1, ...
			'units', 'normalized', ...
			'Tag', [featureTypes{ii} 'Panel'], ...
			'position', [tmpobjpos(1)+(double(jj == 2)*(tmpobjdim+tmpgap)) 0.15 tmpobjdim 0.8375], ...
			'backgroundcolor', DEMSRColor, ...
			'title', [' Image ' num2str(jj)  ' ' featureTypes{ii} ' Options '], ...
			'fontsize', defaultFontsize, ...
			'fontweight', 'bold', ...
			'Visible', 'off');
		if jj == 1
			%addDocButton(parent, docRef, location, color)
			addDocButton(FTPanels(ii, jj), detectionTypes{ii}, 'lowerleft', highlightColor)
		end
		%[sliderHandle, panelHandle, editHandle] =...
		%    sliderPanel(parent, PanelPVs, SliderPVs, EditPVs, LabelPVs, numFormat);
		% POPULATE OPTIONS
		[objpos, objdim] = distributeObjects(2, 0.025, 1.025, 0.01);%0.025
		switch ii
			case 1 % MSER
				% ThresholdDelta
				tt  = sprintf('Scalar value set within the range: 1e-4 < ThresholdDelta <= 100\nThis value is expressed as a percentage of the input data type range.\nThe percentage specifies the step size between intensity threshold levels used in selecting extremal regions while testing for their stability.\nDecrease this value to return more regions. Typical values range from 0.8 to 4.\nDefault: 2\n(Right-click to reset default.)');
				MSERThresholdDelta1 = 2;
				MSERThresholdDelta2 = 2;
				[MSERThresholdDeltaSlider(jj), ~, MSERThresholdDeltaEdit(jj)] = sliderPanel(FTPanels(ii, jj), ...
					{'title', 'Threshold Delta', ...
					'pos', [0.075 objpos(1) 0.425 objdim], ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'w'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'min', 1e-4, ...
					'max', 10, ...
					'value', MSERThresholdDelta1, ...
					'sliderstep', [0.1/10 1/10], ...
					'tag', ['MSERThresholdDelta'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize}, ...
					{{'backgroundcolor', DEMSRColor, ...
					'foregroundcolor', 'k', 'string', '0+', 'fontsize', defaultFontsize}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k', 'string', '10'}}, ...
					'%0.2f');%#ok
				%MaxAreaVariation
				tt = sprintf('Positive scalar specifying the maximum allowed area variation between extremal regions at varying intensity thresholds.\nIncreasing this value returns a greater number of regions, but they may be less stable.\nStable regions are very similar in size over varying intensity thresholds.\nTypical values range from 0.1 to 1.0.\nDefault: 0.25\n(Right-click to reset default)');
				MSERMaxAreaVariation1 = 0.25;
				MSERMaxAreaVariation2 = 0.25;
				[MSERMaxAreaVariationSlider(jj), ~, MSERMaxAreaVariationEdit(jj)] = sliderPanel(FTPanels(ii, jj), ...
					{'title', 'MaxAreaVariation', ...
					'pos', [0.55 objpos(1) 0.425 objdim], ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'w'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'min', 0, ...
					'max', 5, ...
					'value', MSERMaxAreaVariation1, ...
					'sliderstep', [0.01/1 0.1/1], ...
					'tag', ['MSERMaxAreaVariation'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize}, ...
					{{'backgroundcolor', DEMSRColor, ...
					'foregroundcolor', 'k', 'string', '0+', 'fontsize', defaultFontsize}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k', 'string', '5'}}, ...
					'%0.2f');%#ok
				tt = sprintf('RegionAreaRange is specified as a two-element vector, [minArea maxArea], \nwhich limits the size of the regions (in pixels).\nDefaults: [30 14000]');
				uicontrol(FTPanels(ii, jj), ...
					'style', 'text', ...
					'units', 'normalized', ...
					'FontSize', defaultFontsize+1, ...
					'position', [0.055 0.775 0.25 0.15], ...
					'backgroundcolor', DEMSRColor, ...
					'string', 'Min Area', ...
					'horizontalalignment', 'left', ...
					'tooltipstring', tt);
				%MinArea
				MinMSERArea1 = 30;
				MinMSERArea2 = 30;
				MinMSERAreaEdit(jj) = uicontrol(FTPanels(ii, jj), ...
					'style', 'edit', ...
					'horizontalalignment', 'left', ...
					'units', 'normalized', ...
					'FontSize', defaultFontsize, ...
					'position', [0.3 0.775 0.175 0.175], ...
					'string', MinMSERArea1, ...
					'tag', ['MinMSERArea'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl);%#ok
				uicontrol(FTPanels(ii, jj), ...
					'style', 'text', ...
					'units', 'normalized', ...
					'FontSize', defaultFontsize+1, ...
					'position', [0.525 0.775 0.25 0.15], ...
					'backgroundcolor', DEMSRColor, ...
					'string', 'Max Area', ...
					'horizontalalignment', 'left', ...
					'tooltipstring', tt);
				%MaxArea
				MaxMSERArea1 = 14000;
				MaxMSERArea2 = 14000;
				MaxMSERAreaEdit(jj) = uicontrol(FTPanels(ii, jj), ...
					'style', 'edit', ...
					'units', 'normalized', ...
					'FontSize', defaultFontsize, ...
					'position', [0.775 0.775 0.175 0.175], ...
					'string', MaxMSERArea1, ...
					'tag', ['MaxMSERArea'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl);%#ok
			case 2 % SURF
				% SURFMetricThreshold:
				tt = sprintf('A non-negative scalar which specifies a\nthreshold for selecting the strongest features. To return\nmore blobs, decrease the value of this threshold.\nDefault: 1000.0 (Right-click to reset default).');
				SURFMetricThreshold1 = 1000;%Initial values
				SURFMetricThreshold2 = 1000;
				[SURFMetricThresholdSlider(jj), ~, SURFMetricThresholdEdit(jj)] = sliderPanel(FTPanels(ii, jj), ...
					{'title', 'MetricThreshold', ...
					'pos', [0.075 objpos(1) 0.425 objdim], ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'w'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'min', 1, ...
					'max', 10000, ...
					'value', SURFMetricThreshold1, ...
					'sliderstep', [10/9999 100/9999], ...
					'tag', ['SURFMetricThreshold' num2str(jj)], ...%SLIDER updates value
					'tooltipstring', tt, ...
					'callback', @updateUIControl}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize}, ...
					{{'backgroundcolor', DEMSRColor, ...
					'foregroundcolor', 'k', ...
					'string', '0'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k', 'string', '10K'}}, ...
					'%0.0f');%#ok
				% NumSURFOctaves:
				tt = sprintf('Number of octaves to use. This parameter must be\nan integer scalar greater than or equal to 1. Increase this\nvalue to detect larger blobs. Recommended values are between\n1 and 4. Higher octaves use larger filters and subsample the\nimage data.  Larger number of octaves will result in finding\nlarger size blobs. Set the NumOctaves parameter appropriately\nfor the image size. For example, a 50-by-50 image should not\nrequire you to set the NumOctaves parameter, greater than 2.\nThe NumScaleLevels parameter controls the number of filters\nused per octave. At least three levels are required to\nanalyze the data in a single octave.\n(NOTE: If a non-integer value is selected, it will be rounded.)\nDefault: 3 (Right-click to reset default).');
				NumSURFOctaves1 = 3;
				NumSURFOctaves2 = 3;
				[NumSURFOctavesSlider(jj), ~, NumSURFOctavesEdit(jj)] = sliderPanel(FTPanels(ii, jj), ...
					{'title', 'NumOctaves', ...
					'pos', [mean([0.075, 0.55]) objpos(2) 0.425 0.8*objdim], ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'w'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'min', 1, ...
					'max', 10, ...
					'value', NumSURFOctaves1, ...
					'sliderstep', [1/9 3/9], ...
					'tag', ['NumSURFOctaves'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k'}, ...
					'%0.0f');%#ok
				% NumSURFScaleLevels:
				tt = sprintf('Number of  scale levels to compute per octave.\nThis parameter must be an integer scalar, \ngreater than or equal to 3. Increase this number\nto detect more blobs at finer scale increments.\nRecommended values are between 3 and 6.\n(NOTE: If a non-integer value is selected, it will be rounded.)\nDefault: 4 (Right click to reset default)');
				NumSURFScaleLevels1 = 4;
				NumSURFScaleLevels2 = 4;
				[NumSURFScaleLevelsSlider(jj), ~, NumSURFScaleLevelsEdit(jj)] = sliderPanel(FTPanels(ii, jj), ...
					{'title', 'NumScaleLevels', ...
					'pos', [0.55 objpos(1) 0.425 objdim], ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'w'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'min', 3, ...
					'max', 10, ...
					'value', NumSURFScaleLevels1, ...
					'sliderstep', [1/7 2/7], ...
					'tag', ['NumSURFScaleLevels'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k'}, ...
					'%0.0f');%#ok
			case 3 % Harris (Corner)
				uicontrol(FTPanels(ii, jj), ...
					'style', 'text', ...
					'units', 'normalized', ...
					'FontSize', defaultFontsize-1, ...
					'fontweight', 'bold', ...
					'position', [0.05 0.5 0.9 0.45], ...
					'backgroundcolor', DEMSRColor, ...
					'string', dragROIString, ...
					'horizontalalignment', 'left', ...
					'tooltipstring', tt);				
				%MinQuality
				tt = sprintf('The minimum accepted quality of corners represents\na fraction of the maximum corner metric value in the image.\nLarger values can be used to remove erroneous corners.\nDefault = 0.01;\n(Right-click to reset default.)\nDoc: detectHarrisFeatures');
				MinHarrisQuality1 = 0.01;
				MinHarrisQuality2 = 0.01;
				[MinHarrisQualitySlider(jj), ~, MinHarrisQualityEdit(jj)] = sliderPanel(FTPanels(ii, jj), ...
					{'title', 'MinQuality', ...
					'pos', [0.075 objpos(1) 0.425 objdim], ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'w'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'min', 0, ...
					'max', 1, ...
					'value', MinHarrisQuality1, ...
					'sliderstep', [1/100 1/10], ...
					'tag', ['MinHarrisQuality'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k'}, ...
					'%0.2f');%#ok
				%FilterSize
				tt = sprintf('Odd integer scalar specifying the Gaussian filter dimension. The function uses the FilterSize value to calculate the filter''s dimensions, FilterSize-by-FilterSize.\nIt also defines the standard deviation of the Gaussian filter as FilterSize/3.\nNOTE: FilterSize may not exceed the minimum image dimension;it will be capped accordingly herein.\nDefault: 5.\n(Right-Click to reset default.)');
				HarrisFilterSize1 = 5;
				HarrisFilterSize2 = 5;
				[HarrisFilterSizeSlider(jj), ~, HarrisFilterSizeEdit(jj)] = sliderPanel(FTPanels(ii, jj), ...
					{'title', 'FilterSize', ...
					'pos', [0.55 objpos(1) 0.425 objdim], ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'w'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'min', 3, ...
					'max', 3000, ...
					'value', HarrisFilterSize1, ...
					'sliderstep', [1/2997 100/2997], ...
					'tag', ['HarrisFilterSize'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k'}, ...
					'%0.0f');%#ok
			case 4 % Min Eigenvalue (Corner)
								uicontrol(FTPanels(ii, jj), ...
					'style', 'text', ...
					'units', 'normalized', ...
					'FontSize', defaultFontsize-1, ...
					'fontweight', 'bold', ...
					'position', [0.05 0.5 0.9 0.45], ...
					'backgroundcolor', DEMSRColor, ...
					'string', dragROIString, ...
					'horizontalalignment', 'left', ...
					'tooltipstring', tt);				
				%MinQuality
				tt = sprintf('The minimum accepted quality of corners represents\na fraction of the maximum corner metric value in the image.\nLarger values can be used to remove erroneous corners.\nDefault = 0.01;\n(Right-click to reset default.');
				MinEigenQuality1 = 0.01;
				MinEigenQuality2 = 0.01;
				[MinEigenQualitySlider(jj), ~, MinEigenQualityEdit(jj)] = sliderPanel(FTPanels(ii, jj), ...
					{'title', 'MinQuality', ...
					'pos', [0.075 objpos(1) 0.425 objdim], ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'w'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'min', 0, ...
					'max', 1, ...
					'value', MinEigenQuality1, ...
					'sliderstep', [1/100 1/10], ...
					'tag', ['MinEigenQuality'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k'}, ...
					'%0.3f');%#ok
				%FilterSize
				tt = sprintf('Odd integer scalar specifying the Gaussian filter dimension. The function uses the FilterSize value to calculate the filter''s dimensions, FilterSize-by-FilterSize.\nIt also defines the standard deviation of the Gaussian filter as FilterSize/3.\nNOTE: FilterSize may not exceed the minimum image dimension;it will be capped accordingly herein.\nDefault: 5.\n(Right-Click to reset default.)');
				EigenFilterSize1 = 5;
				EigenFilterSize2 = 5;
				[EigenFilterSizeSlider(jj), ~, EigenFilterSizeEdit(jj)] = sliderPanel(FTPanels(ii, jj), ...
					{'title', 'FilterSize', ...
					'pos', [0.55 objpos(1) 0.425 objdim], ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'w'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'min', 3, ...
					'max', 3000, ...
					'value', EigenFilterSize1, ...
					'sliderstep', [1/2997 100/2997], ...
					'tag', ['EigenFilterSize'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k'}, ...
					'%0.0f');%#ok
			case 5 % FAST (Corner)
				uicontrol(FTPanels(ii, jj), ...
					'style', 'text', ...
					'units', 'normalized', ...
					'FontSize', defaultFontsize-1, ...
					'fontweight', 'bold', ...
					'position', [0.05 0.5 0.9 0.45], ...
					'backgroundcolor', DEMSRColor, ...
					'string', dragROIString, ...
					'horizontalalignment', 'left', ...
					'tooltipstring', tt);
				%MinQuality
				tt = sprintf('The minimum accepted quality of corners represents\na fraction of the maximum corner metric value in the image.\nLarger values can be used to remove erroneous corners.\nDefault = 0.01;\n(Right-click to reset default.');
				MinFASTQuality1 = 0.01;
				MinFASTQuality2 = 0.01;
				[MinFASTQualitySlider(jj), ~, MinFASTQualityEdit(jj)] = sliderPanel(FTPanels(ii, jj), ...
					{'title', 'MinQuality', ...
					'pos', [0.075 objpos(1) 0.425 objdim], ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'w'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'min', 0, ...
					'max', 1, ...
					'value', MinFASTQuality1, ...
					'sliderstep', [1/100 1/10], ...
					'tag', ['MinFASTQuality'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k'}, ...
					'%0.2f');%#ok
				%MinContrast
				tt = sprintf('Minimum intensity difference between corner and surrounding region.\nThe minimum intensity represents a fraction of the maximum value of the image class.\nIncreasing the value reduces the number of detected corners.\nDefault: 0.02.\n(Right-Click to reset default.)');
				MinFASTContrast1 = 0.2;
				MinFASTContrast2 = 0.2;
				[MinFASTContrastSlider(jj), ~, MinFASTContrastEdit(jj)] = sliderPanel(FTPanels(ii, jj), ...
					{'title', 'MinContrast', ...
					'pos', [0.55 objpos(1) 0.425 objdim], ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'w'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'min', 1e-3, ...
					'max', 1-1e-3, ...
					'value', MinFASTContrast1, ...
					'sliderstep', [1/100 1/10], ...
					'tag', ['MinFASTContrast'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize}, ...
					{{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k', ...
					'string', 0}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k', ...
					'string', 1}}, ...
					'%0.2f');%#ok
			case 6 % BRISK (Corner)
				uicontrol(FTPanels(ii, jj), ...
					'style', 'text', ...
					'units', 'normalized', ...
					'FontSize', defaultFontsize-1, ...
					'fontweight', 'bold', ...
					'position', [0.05 0.5 0.9 0.45], ...
					'backgroundcolor', DEMSRColor, ...
					'string', dragROIString, ...
					'horizontalalignment', 'left', ...
					'tooltipstring', tt);				
				%MinQuality
				tt = sprintf('The minimum accepted quality of corners represents\na fraction of the maximum corner metric value in the image.\nLarger values can be used to remove erroneous corners.\nDefault = 0.01;\n(Right-click to reset default.');
				minBRISKQuality1 = 0.1;
				minBRISKQuality2 = 0.1;
				[MinBRISKQualitySlider(jj), ~, MinBRISKQualityEdit(jj)] = sliderPanel(FTPanels(ii, jj), ...
					{'title', 'MinQuality', ...
					'pos', [0.075 objpos(1) 0.425*0.8 objdim], ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'w'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'min', 0, ...
					'max', 1, ...
					'value', minBRISKQuality1, ...
					'sliderstep', [1/100 1/10], ...
					'tag', ['minBRISKQuality'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize}, ...
					{{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k', ...
					'string', 0}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k', ...
					'string', 1}}, ...
					'%0.2f');%#ok
				
				%MinContrast
				tt = sprintf('Minimum intensity difference between corner and surrounding region.\nThe minimum intensity represents a fraction of the maximum value of the image class.\nIncreasing the value reduces the number of detected corners.\nDefault: 0.02.\n(Right-Click to reset default.)');
				minBRISKContrast1 = 0.2;
				minBRISKContrast2 = 0.2;
				[minBRISKContrastSlider(jj), ~, minBRISKContrastEdit(jj)] = sliderPanel(FTPanels(ii, jj), ...
					{'title', 'MinContrast', ...
					'pos', [0.55-0.1 objpos(1) 0.425*0.8 objdim], ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'w'}, ...
					{'backgroundcolor', DEMSRColor, ...
					'min', 1e-4, ...
					'max', 1-1e-4, ...
					'value', minBRISKContrast1, ...
					'sliderstep', [1/100 1/10], ...
					'tag', ['minBRISKContrast'  num2str(jj)], ...
					'tooltipstring', tt, ...
					'callback', @updateUIControl}, ...
					{'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize}, ...
					{{'string', '0+', ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k'}, ...
					{'string', '1-', ...
					'backgroundcolor', DEMSRColor, ...
					'fontsize', defaultFontsize, ...
					'foregroundcolor', 'k'}}, ...
					'%0.2f');%#ok
				uicontrol(FTPanels(ii, jj), ...
					'style', 'text', ...
					'units', 'normalized', ...
					'pos', [0.825 0.5 0.165 0.1], ...
					'backgroundcolor', DEMSRColor, ...
					'foregroundcolor', 'w', ...
					'fontsize', defaultFontsize, ...
					'string', 'NumOct');
				%NumOctaves
				numBRISKOctaves1 = '4';
				numBRISKOctaves2 = '4';
				BriskOctavesOptions = {'0';'1';'2';'3';'4';'5';'6'};
				tt = sprintf('NumOctaves: Number of octaves to implement--an integer scalar, greater than or equal to 0.\nIncrease this value to detect larger blobs. Recommended values are between 1 and 4.\nWhen you set NumOctaves to 0, the function disables multi-scale detection and\nperforms the detection at the scale of the input image, I.');
				numBRISKOctavesListbox(jj) = uicontrol(FTPanels(ii, jj), ...
					'style', 'listbox', ...
					'units', 'normalized', ...
					'pos', [0.825 objpos(1) 0.165 objdim], ...
					'string', BriskOctavesOptions, ...
					'tooltipstring', tt, ...
					'backgroundcolor', DEMSRColor, ...
					'tag', ['numBRISKOctaves' num2str(jj)], ...
					'value', 5, ...
					'callback', @updateUIControl);%#ok
				tt = sprintf('Rectangular region for corner detection, specified as [x y width height].\nDefault: [1 1 size(I, 2) size(I, 1)]');
		end
	end
end
if preBRISK
	set(FTButtons(6), 'visible', 'off')
end
linkpropsCheckbox = uicontrol(uipanel1, ...
	'units', 'normalized', ...
	'tag', 'linkProps12', ...
	'backgroundcolor', get(uipanel1, 'backgroundcolor'), ...
	'fontweight', 'bold', ...
	'style', 'checkbox', ...
	'fontsize', defaultFontsize+1, ...
	'value', true, ...
	'string', 'Link relevant image-2 property settings to image-1 property settings', ...
	'position', [tmpobjpos(1) 0.025 0.7 0.1]);
%
% sliderPanels require extra attention to keep textboxes appropriately
% linked
% NOTE: Filter sizes are functions of image size;they shouldn't be linked
% in this manner. [%HarrisFilterSizeSlider;	EigenFilterSizeSlider;]
linkages = [...
	MSERThresholdDeltaSlider;
	MSERMaxAreaVariationSlider;
	SURFMetricThresholdSlider;
	NumSURFOctavesSlider;
	NumSURFScaleLevelsSlider;
	MinHarrisQualitySlider;
	MinEigenQualitySlider;
	MinFASTQualitySlider;
	MinFASTContrastSlider;
	MinBRISKQualitySlider;
	minBRISKContrastSlider;
	MinMSERAreaEdit;
	MaxMSERAreaEdit;
	numBRISKOctavesListbox;
	];
%
%Initialize with SURF visible:
set(FTPanels(1, :), 'visible', 'on');
%
% (EXTRACTOR/DESCRIPTOR TYPE)
uipanel2 = uipanel('parent', registerAlignPanel, ...
	'Units', 'normalized', ...
	'Position', [0.055 PB(2) 0.93 PH(2)], ...
	'Tag', 'uipanel2', ...
	'Title', ' INTEREST-POINT DESCRIPTOR TYPE AND OPTIONS FOR FEATURE EXTRACTION ', ...
	'TitlePosition', 'lefttop', ...
	'BorderType', 'etchedin', ...
	'BorderWidth', 1, ...
	'BackgroundColor', DEMSRColor, ...
	'ForegroundColor', highlightColor, ...
	'FontName', 'MS Sans Serif', ...
	'FontSize', defaultFontsize+1, ...
	'FontWeight', 'bold');
addDocButton(uipanel2, 'extractFeatures', 'lowerleft', highlightColor)
extractorTypes = {'Auto', ...
	'FREAK', ...
	'SURF', ...
	'Block', ...
	'HOG', ...
	'BRISK'};
tts = {...
	sprintf('The function selects the method based on the class of the input points.\nFor a cornerPoints input, the function implements the FREAK method.\nFor a SURFPoints or MSERRegions input, the function implements the SURF method.\nWhen you use an MSERRegions object with the SURF method, the Centroid property of the object is used to extract SURF descriptors.\nThe Axes property of the object is used to select the scale of the SURF descriptors such that the circle representing the feature has an area proportional to the MSER ellipse area.\nThe scale is calculated as 1/4*sqrt((majorAxes/2).*(minorAxes/2)) and saturated to 1.6 as required by the SURFPoints object.\nThe Orientation of the object is not used.\nFor an M-by-2 matrix of [x y] coordinates input, the function implements the Block method\n(DOC: extractFeatures)'), ...
	sprintf('Fast Retina Keypoint (FREAK).\nThe function sets the Orientation property of the validPoints output object to the orientation of the extracted features, in radians.\n(DOC: extractFeatures)'), ...
	sprintf('Speeded-Up Robust Features (SURF).\nThe function sets the Orientation property of the validPoints output object to the orientation of the extracted features, in radians.\n(DOC: extractFeatures)'), ...
	sprintf('Simple square neighbhorhood.\nThe Block method extracts only the neighborhoods fully contained within the image boundary. Therefore, the output, validPoints may contain fewer points than the input POINTS.\n(DOC: extractFeatures)'), ...
	sprintf('Histogram of Oriented Gradients'), ...
	sprintf('Binary Robust Invariant Scalable Keypoints (BRISK).\nThe function sets the Orientation property of the validPoints output object to the orientation of the extracted features, in radians.\n(DOC: extractFeatures)')};
%
selectedExtractorType = 'Auto';
extractorTypeBG = uibuttongroup('parent', uipanel2, ...
	'Units', 'normalized', ...
	'Position', [0.025 0.05 0.3 0.9], ...
	'Tag', 'selectedExtractorType', ...%target
	'BorderType', 'etchedin', ...
	'BorderWidth', 1, ...
	'BackgroundColor', DEMSRColor, ...
	buttonGroupChangedFcn, @updateUIControl);
% NOTE: Here we only need one options panel...
extractorTypeButtons = gobjects(numel(extractorTypes), 1);
[objposBG, objdimBG] = distributeObjects(3, 0.975, 0.05, 0.015);
for ii = 1:numel(extractorTypes)
	extractorTypeButtons(ii) = uicontrol(extractorTypeBG, ...
		'style', 'radio', ...
		'units', 'normalized', ...
		'FontSize', defaultFontsize, ...
		'Tag', extractorTypes{ii}, ...
		'position', [double(ii>3)*0.5+0.185 objposBG(rem(ii-1, 3)+1) 0.3 objdimBG], ...
		'string', extractorTypes{ii}, ...
		'backgroundcolor', DEMSRColor, ...
		'tooltipstring', tts{ii});
end
if preBRISK
	set(extractorTypeButtons(6), 'visible', 'off')
end
ExtractorTypeOptsPanel1 = uipanel(uipanel2, ...
	'units', 'normalized', ...
	'position', [0.35 0.05 0.525+0.1 0.9], ...
	'backgroundcolor', DEMSRColor, ...
	'Tag', 'ETOptsPanel', ...
	'Visible', 'on');
% BlockSize:
BlockSize = 11;
tt = sprintf('Odd integer scalar specifying the block size, defining the local square neighborhood\nBlockSize-by-BlockSize, centered at each interest point.\nThis option only applies when the function implements the Block method.\n(NOTE: If a value other than an odd integer is selected, it will be rounded appropriately.)\nDefault: 11. (Right-Click to reset default.)');
[blockSliderUIControl(1), ~, blockSliderUIControl(2)] = sliderPanel(ExtractorTypeOptsPanel1, ...
	{'title', 'BlockSize', ...
	'pos', [0.05 0.05 0.5 0.9], ...
	'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'w'}, ...
	{'backgroundcolor', DEMSRColor, ...
	'min', 3, ...
	'max', 31, ...
	'value', BlockSize, ...
	'sliderstep', [2/28 4/28], ...
	'tag', 'BlockSize', ...
	'callback', @updateUIControl, ...
	'tooltipstring', tt}, ...
	{'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize}, ...
	{'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'k'}, ...
	'%0.0f');
% SURFSize:
%NOTE: I specify this as a string for coding simplicity;MatchMetric is a
%string, auto-extracted from a listbox
SURFSize = '64';
SURFSizeOpts = {'64';'128'};
tt = sprintf('Length of the SURF feature vector (descriptor), specified as the comma-separated pair\nconsisting of ''SURFSize'' and either the integer scalar 64 or 128.\nThis option only applies when the function implements the SURF method.\nThe larger SURFSize of 128 provides greater accuracy, but decreases the feature matching speed.\n(Default: 64)');
uicontrol(ExtractorTypeOptsPanel1, ...
	'style', 'text', ...
	'units', 'normalized', ...
	'Fontsize', defaultFontsize, ...
	'ForegroundColor', 'w', ...
	'position', [0.6 0.55 0.35 0.25], ...
	'backgroundcolor', DEMSRColor, ...
	'Fontsize', defaultFontsize, ...
	'string', 'SURFSize', ...
	'Fontweight', 'bold');
SURFSizeListbox = uicontrol(ExtractorTypeOptsPanel1, ...
	'style', 'listbox', ...
	'units', 'normalized', ...
	'Fontsize', defaultFontsize, ...
	'position', [0.6 0.05 0.35 0.5], ...
	'backgroundcolor', DEMSRColor, ...
	'string', SURFSizeOpts, ...
	'tag', 'SURFSize', ...
	'tooltipstring', tt, ...
	'value', 1, ...
	'listboxtop', 1, ...
	'callback', @updateUIControl);
%
[objpos, objdim] = distributeObjects(5, 0.015, 0.85, 0.03);
HOGProps = uipanel(uipanel2, ...
	'Units', 'normalized', ...
	'Position', get(ExtractorTypeOptsPanel1, 'position'), ...
	'Tag', 'HOGProps', ...
	'BackgroundColor', DEMSRColor, ...
	'ForegroundColor', highlightColor, ...
	'visible', 'off');
tt = sprintf('Size of HOG cell, specified in pixels as a 2-element vector.\nTo capture large-scale spatial information, increase the cell size.\nWhen you increase the cell size, you may lose small-scale detail.\nDefault: [8x8]\n(DOC: extractHOGFeatures)');
uicontrol(HOGProps, ...
	'style', 'text', ...
	'units', 'normalized', ...
	'position', [objpos(1) 0.775 objdim 0.175], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', 'CellSize:', ...
	'fontsize', defaultFontsize);
HOGCellSize1 = 8;
HOGCellSize1Edit = uicontrol(HOGProps, ...
	'style', 'edit', ...
	'units', 'normalized', ...
	'position', [objpos(1) 0.5 objdim 0.2], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', HOGCellSize1, ...
	'tag', 'HOGCellSize1', ...
	'fontsize', defaultFontsize, ...
	'tooltipstring', tt, ...
	'callback', @updateUIControl);
uicontrol(HOGProps, ...
	'style', 'text', ...
	'units', 'normalized', ...
	'position', [objpos(1) 0.325 objdim 0.15], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', 'x', ...
	'fontsize', defaultFontsize);
HOGCellSize2 = 8;
HOGCellSize2Edit = uicontrol(HOGProps, ...
	'style', 'edit', ...
	'units', 'normalized', ...
	'position', [objpos(1) 0.05 objdim 0.2], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', HOGCellSize2, ...
	'tag', 'HOGCellSize2', ...
	'fontsize', defaultFontsize, ...
	'tooltipstring', tt, ...
	'callback', @updateUIControl);
tt = sprintf('Number of cells in a block, specified as a 2-element vector.\nA large block size reduces the ability to suppress local illumination changes.\n(Because of the number of pixels in a large block, these changes may get lost with averaging.)\nReducing the block size helps to capture the significance of local pixels.\nSmaller block size can help suppress illumination changes of HOG features.\nDefault: [2x2]\n(DOC: extractHOGFeatures)');
uicontrol(HOGProps, ...
	'style', 'text', ...
	'units', 'normalized', ...
	'position', [objpos(2) 0.775 objdim 0.175], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', 'BlockSize:', ...
	'fontsize', defaultFontsize);
HOGBlockSize1 = 2;
HOGBlockSize1Edit = uicontrol(HOGProps, ...
	'style', 'edit', ...
	'units', 'normalized', ...
	'position', [objpos(2) 0.5 objdim 0.2], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', HOGBlockSize1, ...
	'tag', 'HOGBlockSize1', ...
	'fontsize', defaultFontsize, ...
	'tooltipstring', tt, ...
	'callback', @updateUIControl);
uicontrol(HOGProps, ...
	'style', 'text', ...
	'units', 'normalized', ...
	'position', [objpos(2) 0.325 objdim 0.15], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', 'x', ...
	'fontsize', defaultFontsize);
HOGBlockSize2 = 2;
HOGBlockSize2Edit = uicontrol(HOGProps, ...
	'style', 'edit', ...
	'units', 'normalized', ...
	'position', [objpos(2) 0.05 objdim 0.2], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', HOGBlockSize2, ...
	'tag', 'HOGBlockSize2', ...
	'fontsize', defaultFontsize, ...
	'tooltipstring', tt, ...
	'callback', @updateUIControl);
annotation('line', ...
	[0.262 0.262], [0.665 0.725], ...
	'color', 'w', ...
	'visible', 'off', ...
	'tag', 'HOGAnnotation');
tt = sprintf('Number of overlapping cells between adjacent blocks, specified as a 2-element vector.\nTo ensure adequate contrast normalization, select an overlap of at least half the block size.\nLarge overlap values can capture more information, but they produce larger feature vector size.\nWhen you are extracting HOG features around a point location, only one block is used, and thus, no overlap occurs.\n(Because of the number of pixels in a large block, these changes may get lost with averaging.)\nReducing the block size helps to capture the significance of local pixels.\nSmaller block size can help suppress illumination changes of HOG features.\nDefault: ceil(BlockSize/2)\n(DOC: extractHOGFeatures)');
uicontrol(HOGProps, ...
	'style', 'text', ...
	'units', 'normalized', ...
	'position', [objpos(3) 0.775 objdim 0.175], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', 'BlockOverlap:', ...
	'fontsize', defaultFontsize);
HOGBlockOverlap1 = 1;
HOGBlockOverlap1Edit = uicontrol(HOGProps, ...
	'style', 'edit', ...
	'units', 'normalized', ...
	'position', [objpos(3) 0.5 objdim 0.2], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', HOGBlockOverlap1, ...
	'tag', 'HOGBlockOverlap1', ...
	'fontsize', defaultFontsize, ...
	'tooltipstring', tt, ...
	'callback', @updateUIControl);
uicontrol(HOGProps, ...
	'style', 'text', ...
	'units', 'normalized', ...
	'position', [objpos(3) 0.325 objdim 0.15], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', 'x', ...
	'fontsize', defaultFontsize);
HOGBlockOverlap2 = 1;
HOGBlockOverlap2Edit = uicontrol(HOGProps, ...
	'style', 'edit', ...
	'units', 'normalized', ...
	'position', [objpos(3) 0.05 objdim 0.2], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', HOGBlockOverlap2, ...
	'tag', 'HOGBlockOverlap2', ...
	'fontsize', defaultFontsize, ...
	'tooltipstring', tt, ...
	'callback', @updateUIControl);
annotation('line', ...
	[0.305 0.305], [0.665 0.725], ...
	'color', 'w', ...
	'visible', 'off', ...
	'tag', 'HOGAnnotation');
tt = sprintf('Number of orientation histogram bins, specified as a positive scalar.\nTo encode finer orientation details, increase the number of bins.\nIncreasing this value increases the size of the feature vector, which requires more time to process.\nDefault: 9\n(DOC: extractHOGFeatures)');
uicontrol(HOGProps, ...
	'style', 'text', ...
	'units', 'normalized', ...
	'position', [objpos(4) 0.775 objdim 0.175], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', 'NumBins:', ...
	'fontsize', defaultFontsize);
numHOGBins = 9;
numHOGBinsEdit = uicontrol(HOGProps, ...
	'style', 'edit', ...
	'units', 'normalized', ...
	'position', [objpos(4) 0.5 objdim 0.2], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', numHOGBins, ...
	'tag', 'numHOGBins', ...
	'fontsize', defaultFontsize, ...
	'tooltipstring', tt, ...
	'callback', @updateUIControl);
annotation('line', ...
	[0.348 0.348], [0.665 0.725], ...
	'color', 'w', ...
	'visible', 'off', ...
	'tag', 'HOGAnnotation');
UseSignedOrientation = false;
tt = sprintf('Selection of orientation values, specified as a logical scalar.\nWhen you set this property to true, orientation values are evenly spaced in bins between -180 and 180 degrees.\nWhen you set this property to false, they are evenly spaced from 0 through 180.\nIn this case, values of theta that are less than 0 are placed into a theta + 180 value bin.\nUsing signedorientation can help differentiate light-to-dark versus dark-to-light transitions within an image region.\nDefault: false\n(DOC: extractHOGFeatures)');
UseSignedOrientationCheckbox = uicontrol(HOGProps, ...
	'style', 'checkbox', ...
	'units', 'normalized', ...
	'position', [objpos(4) 0.05 0.985-objpos(4) 0.2], ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', get(HOGProps, 'backgroundcolor'), ...
	'string', 'Use Signed Orientation', ...
	'tag', 'UseSignedOrientation', ...
	'fontsize', defaultFontsize, ...
	'tooltipstring', tt, ...
	'callback', @updateUIControl);

% (MATCHING OPTIONS)
uipanel3 = uipanel('parent', registerAlignPanel, ...
	'Units', 'normalized', ...
	'Position', [0.055 PB(3) 0.93 PH(3)], ...
	'Tag', 'uipanel2', ...
	'Title', ' FEATURE MATCHING OPTIONS ', ...
	'TitlePosition', 'lefttop', ...
	'BorderType', 'etchedin', ...
	'BorderWidth', 1, ...
	'BackgroundColor', DEMSRColor, ...
	'ForegroundColor', highlightColor, ...
	'FontName', 'MS Sans Serif', ...
	'FontSize', defaultFontsize+1, ...
	'FontWeight', 'Bold');
addDocButton(uipanel3, 'matchFeatures', '', highlightColor)
% MatchMethod
%tt = sprintf('Matching method, specified as the comma-separated pair consisting of ''Method'' and a string.\nAll three methods use the match threshold.\nTwo feature vectors match when the distance between them is less than the threshold set by the MatchThreshold parameter.');
MatchMethod = 'NearestNeighborRatio';
matchingMethodBG = uibuttongroup(uipanel3, ...
	'Units', 'normalized', ...
	'Position', [0.025 0.075 0.4 0.9], ...
	'Tag', 'MatchMethod', ...%target
	'TitlePosition', 'lefttop', ...
	'Title', ' Matching Method ', ...
	'BorderType', 'etchedin', ...
	'BorderWidth', 1, ...
	'BackgroundColor', DEMSRColor, ...
	'ForegroundColor', [1 1 1], ...
	'FontName', 'MS Sans Serif', ...
	'FontSize', defaultFontsize, ...
	'HighlightColor', [1 1 1], ...
	'ShadowColor', [0.500 0.500 0.500], ...
	buttonGroupChangedFcn, @updateUIControl);
%
matchingOptions = {'NearestNeighborRatio', ...
	'Threshold', ...
	'NearestNeighborSymmetric'};
tts = {...
	sprintf('(DEFAULT)\nEliminates ambiguous matches in addition to using the match threshold.\nA feature vector is matched to its nearest neighbor in the other feature set\nwhen the nearest neighbor satisfies a ratio test. The ratio test compares the distances from the feature vector to its first and second\nnearest neighbors in the other feature set.\n(DOC: matchFeatures)')
	sprintf('Uses only the match threshold. This method can return more than one match for each feature.\n(Doc: matchFeatures)');
	sprintf('Returns only unique matches in addition to using the match threshold.\nA feature vector only matches to its nearest neighbor in the other feature set.\n(Doc: matchFeatures)');};
matchingTypeButtons = gobjects(numel(matchingOptions), 1);
[objposBG, objdimBG] = distributeObjects(3, 0.975, 0.05, 0.015);
for ii = 1:numel(matchingOptions)
	matchingTypeButtons(ii) = uicontrol(matchingMethodBG, ...
		'style', 'radio', ...
		'units', 'normalized', ...
		'Tag', matchingOptions{ii}, ...
		'FontSize', defaultFontsize, ...
		'position', [0.1 objposBG(ii) 0.475+0.4 objdimBG], ...
		'string', matchingOptions{ii}, ...
		'backgroundcolor', DEMSRColor, ...
		'tooltipstring', tts{ii});
end
% MaxRatio:
tt = sprintf('Ratio threshold, specified as a scalar value in the range (0, 1] for rejecting ambiguous matches.\nIncrease this value to return more matches.\nThis parameter only applies when you set the Method parameter to NearestNeighborRatio.\nDefault: 0.6. (Right-click to reset default.)\n(Doc: matchFeatures)');
MaxRatio = 0.6;
MaxRatioSlider = sliderPanel(uipanel3, ...
	{'title', 'MaxRatio', ...
	'pos', [0.4375 0.075 0.16 0.9], ...
	'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'w'}, ...
	{'backgroundcolor', DEMSRColor, ...
	'min', 1e-5, ...
	'max', 1, ...
	'value', MaxRatio, ...
	'sliderstep', [0.01/(1-1e-5) 0.1/(1-1e-5)], ...
	'tag', 'MaxRatio', ...
	'callback', @updateUIControl, ...
	'tooltipstring', tt}, ...
	{'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize, ...
	'tag', 'MaxRatioEdit'}, ...
	{{'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'k', 'string', '0+', 'fontsize', defaultFontsize}, ...
	{'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'k', 'string', '1'}}, ...
	'%0.2f');
% MatchThreshold:
tt = sprintf('Threshold, specified as a scalar percent value in the range (0, 100) for selecting the strongest matches.\nMatches having a metric more than this percent value from a perfect match are rejected.\nIncrease this value to return more matches.\nDefault: 10.0 for binary feature vectors;1.0 non-binary feature vectors (default)\n(Doc: matchFeatures)');
MatchThreshold = 10;
MatchThresholdSlider = sliderPanel(uipanel3, ...
	{'title', 'MatchThreshold', ...
	'pos', [0.6075 0.075 0.16 0.9], ...
	'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'w'}, ...
	{'backgroundcolor', DEMSRColor, ...
	'min', 1e-4, ...
	'max', 100, ...
	'value', MatchThreshold, ...
	'sliderstep', [1/(100-1e-4) 10/(100-1e-4)], ...
	'tag', 'MatchThreshold', ...
	'callback', @updateUIControl, ...
	'tooltipstring', tt}, ...
	{'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize, ...
	'tag', 'MatchThresholdEdit'}, ...
	{{'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'k', 'string', '0+', 'fontsize', defaultFontsize}, ...
	{'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'k', 'string', '100'}}, ...
	'%0.1f');
% Metric
tt = sprintf('Feature matching metric, specified as a string. Possible values for the metric are:\nSSD (Sum of squared differences) [DEFAULT];\nSAD (Sum of absolute differences;);\nnormxcorr (Normalized cross-correlation).\nThis parameter only applies when the input feature set, features1 and features2, \nare NOT binaryFeatures objects.\nWhen the input feature set is binary, the function uses the Hamming distance\nto compute the similarity metric.\nDoc: matchFeatures.');
uicontrol(uipanel3, ...
	'style', 'text', ...
	'units', 'normalized', ...
	'Fontsize', defaultFontsize, ...
	'ForegroundColor', 'w', ...
	'position', [0.79 0.85 0.185 0.15], ...
	'backgroundcolor', DEMSRColor, ...
	'string', 'Metric');
matchMetricOpts = {'SSD';'SAD';'normxcorr'};
MatchMetric = 'SSD';
MatchMetricListbox = uicontrol(uipanel3, ...
	'style', 'listbox', ...
	'units', 'normalized', ...
	'Fontsize', defaultFontsize, ...
	'position', [0.79 0.225 0.185 0.6], ...
	'backgroundcolor', DEMSRColor, ...
	'string', matchMetricOpts, ...
	'tag', 'MatchMetric', ...
	'tooltipstring', tt, ...
	'value', 1, ...
	'listboxtop', 1, ...
	'callback', @updateUIControl);

% Prenormalized
Prenormalized = false;
tt = sprintf('Prenormalize indicator, specified as a logical scalar.\nSet this value to true before matching when the input feature set, features1 and features2, \nare already normalized to unit vectors.\nWhen this value is false, the function normalizes features1 and features2.\nWhen this value is true and features are not normalized in advance, the function produces wrong results.\nThis parameter applies only when the input feature set does not contain binary Features objects.\nDefault: false\nDoc: matchFeatures.');
PrenormalizedCheckbox = uicontrol(uipanel3, ...
	'style', 'checkbox', ...
	'units', 'normalized', ...
	'FontSize', defaultFontsize, ...
	'position', [0.79 0.065 0.185 0.125], ...
	'Tag', 'Prenormalized', ...
	'backgroundcolor', DEMSRColor, ...
	'string', 'Prenormalized', ...
	'tooltipstring', tt, ...
	'value', Prenormalized, ...
	'callback', @updateUIControl);

% VISUALIZATION
uipanel4 = uipanel('parent', registerAlignPanel, ...
	'Units', 'normalized', ...
	'Position', [0.055 PB(4) 0.93 PH(4)], ...
	'Tag', 'uipanel2', ...
	'Title', ' FEATURE/MATCH VISUALIZATION OPTIONS ', ...
	'TitlePosition', 'lefttop', ...
	'BorderType', 'etchedin', ...
	'BorderWidth', 1, ...
	'BackgroundColor', DEMSRColor, ...
	'ForegroundColor', highlightColor, ...
	'FontName', 'MS Sans Serif', ...
	'FontSize', defaultFontsize+1, ...
	'FontWeight', 'bold');

[objpos, objdim] = distributeObjects(5, 0.025, 0.975, 0.0125);
NumStrongest = 10;
tt = sprintf('Number of strongest features to show.\nDefault: 10. (Right-click to reset default.)');
NumStrongestSlider = sliderPanel(uipanel4, ...
	{'title', '# of Features to Show', ...
	'pos', [objpos(1) 0.075 objdim 0.9], ...
	'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'w'}, ...
	{'backgroundcolor', DEMSRColor, ...
	'min', 0, ...
	'max', 100, ...
	'value', NumStrongest, ...
	'sliderstep', [1/100 10/100], ...
	'tag', 'NumStrongest', ...
	'callback', {@showFeatures, 1}, ...%updateImagesAndFeatures, ...
	'tooltipstring', tt}, ...
	{'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize}, ...
	{'backgroundcolor', DEMSRColor, ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'k'}, ...
	'%0.0f');
putativeMatchesBG = uibuttongroup(uipanel4, ...
	'Units', 'normalized', ...
	'Position', [objpos(2) 0.075 2*objdim+0.0125 0.9], ...0.975-objpos(2)
	'Tag', 'putativeMatchMethod', ...
	'TitlePosition', 'lefttop', ...
	'Title', ' Show Putative Matches As... ', ...
	'BorderType', 'etchedin', ...
	'BorderWidth', 1, ...
	'BackgroundColor', DEMSRColor, ...
	'ForegroundColor', [1 1 1], ...
	'FontName', 'MS Sans Serif', ...
	'FontSize', defaultFontsize, ...
	'HighlightColor', [1 1 1], ...
	'ShadowColor', [0.500 0.500 0.500], ...
	buttonGroupChangedFcn, @updateUIControl);
putativeMatchingOptions = {'FalseColor', ...
	'Blend', ...
	'Montage'};
tts = {...
	sprintf('(DEFAULT)\nCreates a composite RGB image showing A and B overlaid in different color bands.\nGray regions in the composite image show where the two images have the same intensities.\nMagenta and green regions show where the intensities are different.\n(DOC: imshowpair)')
	sprintf('Overlays A and B using alpha blending.\n(Doc: imshowpair)');
	sprintf('Places A and B next to each other in the same image.\n(Doc: imshowpair)');};
putativeMatchingButtons = gobjects(numel(matchingOptions), 1);
[objposBG, objdimBG] = distributeObjects(3, 0.05, 0.975, 0.005);
putativeMatchMethod = putativeMatchingOptions{1};
for ii = 1:numel(putativeMatchingOptions)
	putativeMatchingButtons(ii) = uicontrol(putativeMatchesBG, ...
		'style', 'radio', ...
		'units', 'normalized', ...
		'Tag', putativeMatchingOptions{ii}, ...putativeMatchingOptions{ii}, ...'putativeMatchMethod' ???
		'FontSize', defaultFontsize, ...
		'position', [objposBG(ii) 0.05 objdimBG 0.8], ...
		'string', putativeMatchingOptions{ii}, ...
		'backgroundcolor', DEMSRColor, ...
		'tooltipstring', tts{ii});
end
addDocButton(putativeMatchesBG, 'imshowpair', '', highlightColor)

rawOrFilteredBG = uibuttongroup(uipanel4, ...
	'Units', 'normalized', ...
	'Position', [objpos(4) 0.075 2*objdim+0.0125 0.9], ...0.975-objpos(2)
	'Tag', 'rawOrFiltered', ...
	'TitlePosition', 'lefttop', ...
	'Title', ' When showing matches... ', ...
	'BorderType', 'etchedin', ...
	'BorderWidth', 1, ...
	'BackgroundColor', DEMSRColor, ...
	'ForegroundColor', [1 1 1], ...
	'FontName', 'MS Sans Serif', ...
	'FontSize', defaultFontsize, ...
	'HighlightColor', [1 1 1], ...
	'ShadowColor', [0.500 0.500 0.500], ...
	buttonGroupChangedFcn, @updateUIControl);
rawOrFilteredOptions = {'Include Outliers', ...
	'Remove Outliers'};
tts = {...
	sprintf('(DEFAULT)\nShow matches prior to outlier removal.')
	sprintf('Show matches after outlier removal.')};
rawOrFilteredButtons = gobjects(numel(rawOrFilteredOptions), 1);
[objposBG, objdimBG] = distributeObjects(2, 0.05, 0.975, 0.015);
rawOrFiltered = rawOrFilteredOptions{1};
for ii = 1:numel(rawOrFilteredButtons)
	rawOrFilteredButtons(ii) = uicontrol(rawOrFilteredBG, ...
		'style', 'radio', ...
		'units', 'normalized', ...
		'Tag', rawOrFilteredOptions{ii}, ...putativeMatchingOptions{ii}, ...'putativeMatchMethod' ???
		'FontSize', defaultFontsize, ...
		'position', [objposBG(ii) 0.05 objdimBG 0.8], ...
		'string', rawOrFilteredOptions{ii}, ...
		'backgroundcolor', DEMSRColor, ...
		'tooltipstring', tts{ii});
end

% REGISTRATION PANEL
uipanel5 = uipanel(registerAlignPanel, ...
	'Units', 'normalized', ...
	'Position', [0.055 PB(5) 0.93 PH(5)], ...
	'Tag', 'regPanel', ...
	'Title', ' REGISTRATION OPTIONS ', ...
	'TitlePosition', 'lefttop', ...
	'BorderType', 'etchedin', ...
	'BorderWidth', 1, ...
	'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'ForegroundColor', highlightColor, ...
	'FontName', 'MS Sans Serif', ...
	'FontSize', defaultFontsize+1, ...
	'FontWeight', 'bold');
addDocButton(uipanel5, 'estimateGeometricTransform', '', highlightColor)

[objpos, objdim] = distributeObjects(4, 0.025, 0.975, 0.0125);
[vobjpos, vobjdim] = distributeObjects(2, 0.75, 0.025, 0.015);
parent = uipanel5;
transformType = 'Affine';
transformTypeBG = uibuttongroup(parent, ...
	'Units', 'normalized', ...
	'Position', [objpos(1) 0.8 objpos(2)+objdim-objpos(1) 0.18], ...
	'Tag', 'transformType', ...
	'TitlePosition', 'lefttop', ...
	'Title', ' Transform Type ', ...
	'BorderType', 'etchedin', ...
	'BorderWidth', 1, ...
	'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'ForegroundColor', [1 1 1], ...
	'FontName', 'MS Sans Serif', ...
	'FontSize', defaultFontsize+1, ...
	'FontWeight', 'bold', ...
	buttonGroupChangedFcn, @updateUIControl);
transformTypes = {'Affine', ...
	'Similarity', ...
	'Projective'};%Rigid would be nice! (G1023473)
% CONSTANT FOR NON-REFLECTIVE SIMILARITY
tts = {...
	sprintf('In an affine transformation, the x and y dimensions can be scaled or sheared independently\nand there may be a translation, a reflection, and/or a rotation. Parallel lines remain parallel. Straight lines remain straight.\nSimilarities are a subset of affine transformations.'), ...
	sprintf('Nonreflective similarity transformations may include a rotation, a scaling, and a translation.\nShapes and angles are preserved. Parallel lines remain parallel. Straight lines remain straight.'), ...
	sprintf('In a projective transformation, quadrilaterals map to quadrilaterals.\nStraight lines remain straight. Affine transformations are a subset of projective transformations.'), ...
	sprintf('Rigid transformations consist of translation and rotation.\nSEE: ''BDS NOTE ON RIGID TRANSFORM'' in code.')};
transformTypeButtons = gobjects(numel(transformTypes), 1);
for ii = 1:numel(transformTypes)
	transformTypeButtons(ii) = uicontrol(transformTypeBG, ...
		'style', 'radio', ...
		'units', 'normalized', ...
		'FontSize', defaultFontsize, ...
		'Tag', transformTypes{ii}, ...
		'position', [objpos(ii) 0.05 objdim 0.9], ...
		'string', transformTypes{ii}, ...
		'BackgroundColor', get(parent, 'backgroundcolor'), ...
		'tooltipstring', tts{ii});
end
tt = sprintf('Maximum number of random trials for finding the inliers.\nIncreasing this value improves the robustness of the results at the expense of additional computations.\nDefault: 100. (Right-click to reset default.)\n(NOTE: The default value in the function is 1000;I think that''s too high, so I use a value of 100 herein.)\nDoc: estimateGeometricTransform');
MaxNumTrials = 1000;
MaxNumTrialsSlider = sliderPanel(parent, ...
	{'title', 'MaxNumTrials', ...
	'pos', [objpos(1) vobjpos(1) objdim vobjdim], ...
	'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'w'}, ...
	{'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'min', 1, ...
	'max', 10000, ...
	'value', MaxNumTrials, ...
	'sliderstep', [100/9999 1000/9999], ...
	'tag', 'MaxNumTrials', ...
	'tooltipstring', tt, ...
	'Callback', @updateUIControl}, ...
	{'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'fontsize', defaultFontsize}, ...
	{'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'k'}, ...
	'%0.0f');
tt = sprintf('Confidence of finding the maximum number of inliers.\nIncreasing this value improves the robustness of the results at the expense of additional computations.\nDefault: 99. (Right-click to reset default.)\nDoc: estimateGeometricTransform');
Confidence = 99;
ConfidenceSlider = sliderPanel(parent, ...
	{'title', 'Confidence', ...
	'pos', [objpos(1) vobjpos(2) objdim vobjdim], ...
	'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'w'}, ...
	{'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'min', 0.01, ...
	'max', 99.99, ...
	'value', Confidence, ...
	'sliderstep', [0.1/99.98 1/99.98], ...
	'tag', 'Confidence', ...
	'tooltipstring', tt, ...
	'Callback', @updateUIControl}, ...
	{'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'fontsize', defaultFontsize}, ...
	{'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'k'}, ...
	'%0.2f');
tt = sprintf('Maximum distance in pixels, from a point to the projection of its corresponding point.\nThe corresponding projection is based on the estimated transform.\nDefault: 1.5. (Right-click to reset default.)\nDoc: estimateGeometricTransform');
MaxDistance = 1.5;
MaxDistanceSlider = sliderPanel(parent, ...
	{'title', 'MaxDistance', ...
	'pos', [objpos(2) vobjpos(1) objdim vobjdim], ...
	'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'w'}, ...
	{'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'min', 0.1, ...
	'max', 10, ...
	'value', MaxDistance, ...
	'sliderstep', [0.1/9.9 1/9.9], ...
	'tag', 'MaxDistance', ...
	'tooltipstring', tt, ...
	'Callback', @updateUIControl}, ...
	{'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'fontsize', defaultFontsize}, ...
	{'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'fontsize', defaultFontsize, ...
	'foregroundcolor', 'k'}, ...
	'%0.1f');
registrationDisplayOptsBG = uibuttongroup(parent, ...
	'Units', 'normalized', ...
	'Position', [objpos(2) vobjpos(2) 0.975-objpos(2) vobjdim], ...
	'Tag', 'registrationDisplayOption', ...
	'TitlePosition', 'lefttop', ...
	'Title', ' Show Registrations As... ', ...
	'BorderType', 'etchedin', ...
	'BorderWidth', 1, ...
	'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'ForegroundColor', [1 1 1], ...
	'FontName', 'MS Sans Serif', ...
	'FontSize', defaultFontsize, ...
	'HighlightColor', [1 1 1], ...
	'ShadowColor', [0.500 0.500 0.500], ...
	buttonGroupChangedFcn, {@updateImageAxes, 4});
addDocButton(registrationDisplayOptsBG, 'imshowpair', '', highlightColor)
%
tt = sprintf('When checked, all uicontrol manipulations will trigger the\n calculation and display of new registrations immediately.\nUnchecked, you may modify several parameters and then\ntrigger the update with the ''Remove Outliers and Register!'' button.');
registerImmediatelyCheckbox = uicontrol(parent, ...
	'style', 'checkbox', ...
	'units', 'normalized', ...
	'position', [objpos(3) vobjpos(1)+0.475 0.75-objpos(3) 0.1], ...
	'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'fontsize', defaultFontsize+2, ...
	'string', 'Update Immediately', ...
	'tooltipstring', tt, ...
	'value', 1);
verbose = false;
tt = sprintf('When checked, replication code is mirrored immediately to the MATLAB Command Line.');
verboseCheckbox = uicontrol(parent, ...
	'style', 'checkbox', ...
	'units', 'normalized', ...
	'position', [objpos(4) vobjpos(1)+0.475 0.75-objpos(3) 0.1], ...
	'BackgroundColor', get(parent, 'backgroundcolor'), ...
	'fontsize', defaultFontsize+2, ...
	'string', 'Verbose', ...
	'tooltipstring', tt, ...
	'value', verbose);
tt = '(Re-)run registration algorithm, using current settings.';
registerNowButton = uicontrol(parent, ...
	'style', 'pushbutton', ...
	'units', 'normalized', ...
	'FontSize', defaultFontsize+4, ...
	'Fontweight', 'bold', ...
	'position', [objpos(3) vobjpos(1) 0.975-objpos(3) 0.935-vobjpos(1)+0.02-0.1], ...
	'Tag', 'RegisterImages', ...
	'BackgroundColor', softenValue*get(parent, 'backgroundcolor'), ...
	'Foregroundcolor', highlightColor, ...
	'string', 'Remove Outliers and Register!', ...
	'tooltipstring', tt, ...
	'callback', @CVOperation);%@registerImages
registrationDisplayOptions = {'FalseColor', ...
	'Blend', ...
	'Diff', ...
	'Montage', ...
	'Flicker', ...
	'CheckerBoard'};
registrationDisplayOption = registrationDisplayOptions{1};
tts = {...
	sprintf('(DEFAULT)\nCreates a composite RGB image showing A and B overlaid in different color bands.\nGray regions in the composite image show where the two images have the same intensities.\nMagenta and green regions show where the intensities are different.\n(DOC: imshowpair)')
	sprintf('Overlays A and B using alpha blending.\n(Doc: imshowpair)');
	sprintf('Creates a difference image from A and B.\n(Doc: imshowpair)');
	sprintf('Places A and B next to each other in the same image.\n(Doc: imshowpair)');
	'Flicker';
	'Checkerboard overlay'};
registrationDisplayButtons = gobjects(numel(registrationDisplayOptions), 1);
vobjpos = repmat([0.55, 0.075], 1, 3);
[objpos, objdim] = distributeObjects(4, 0.055, 0.975, 0.0125);
objpos = repmat(objpos, 2, 1);
for ii = 1:numel(registrationDisplayOptions)
	registrationDisplayButtons(ii) = uicontrol(registrationDisplayOptsBG, ...
		'style', 'radio', ...
		'units', 'normalized', ...
		'Tag', registrationDisplayOptions{ii}, ...
		'FontSize', defaultFontsize, ...
		'position', [objpos(ii) vobjpos(ii) objdim objdim], ...
		'string', registrationDisplayOptions{ii}, ...
		'backgroundcolor', get(parent, 'backgroundcolor'), ...
		'tooltipstring', tts{ii});
end

pauseIcon = im2double(imread(fullfile(matlabroot, ...
	'toolbox', 'shared', 'dastudio', 'resources', 'glue', 'Toolbars', '16px', 'Pause_16.png')));
pauseIcon(pauseIcon == 0) = nan;
startIcon = im2double(imread(fullfile(matlabroot, ...
	'toolbox', 'shared', 'controllib', 'general', 'resources', 'toolstrip_icons', 'Play_16.png')));
startIcon(startIcon == 0) = nan;
uicontrol(registrationDisplayOptsBG, ...
	'style', 'text', ...
	'units', 'normalized', ...
	'Position', [objpos(7)-0.075 vobjpos(3)+0.25 0.25 0.2], ...
	'String', 'FLICKER CONTROLS', ...
	'horizontalalignment', 'left', ...
	'backgroundcolor', get(registrationDisplayOptsBG, 'backgroundcolor'), ...
	'fontweight', 'bold', ...
	'Fontsize', 5);
StartButton = uicontrol(registrationDisplayOptsBG, ...
	'Style', 'pushbutton', ...
	'units', 'normalized', ...
	'Position', [objpos(7)-0.075 vobjpos(3) 0.05 0.25], ...
	'String', '', ...
	'Cdata', startIcon, ...
	'TooltipString', 'Stop/Start Flicker', ...
	'Enable', 'off', ...
	'Callback', @toggleTimerPause, ...
	'Tag', 'PauseRestartFlicker');
ico = im2double(imread(fullfile(matlabroot, ...
	'toolbox', 'shared', 'dastudio', 'resources', 'glue', 'Toolbars', '16px', 'Up_16.png')));
ico(ico == 0) = nan;
FasterButton = uicontrol(registrationDisplayOptsBG, ...
	'units', 'normalized', ...
	'Position', [objpos(7)-0.075+1*0.05 vobjpos(3) 0.05 0.25], ...
	'String', '', ...
	'Cdata', ico, ...
	'Style', 'pushbutton', ...
	'TooltipString', 'Increase flicker frequency', ...
	'Enable', 'off', ...
	'Callback', @flickerFaster, ...
	'Tag', 'FlickerFaster');
ico = cat(3, flipud(ico(:, :, 1)), flipud(ico(:, :, 2)), flipud(ico(:, :, 3)));
SlowerButton = uicontrol(registrationDisplayOptsBG, ...
	'units', 'normalized', ...
	'Position', [objpos(7)-0.075+2*0.05 vobjpos(3) 0.05 0.25], ...
	'String', '', ...
	'Cdata', ico, ...
	'Style', 'pushbutton', ...
	'TooltipString', 'Decrease flicker frequency', ...
	'Enable', 'off', ...
	'Callback', @flickerSlower, ...
	'Tag', 'FlickerSlower');

% IMAGE/FEATURE DISPLAYS
[objpos, objdim] = distributeObjects(2, 0.455, 0.99, 0.025);
[vobjpos, vobjdim] = distributeObjects(2, 0.92, 0.01, 0.1);
axes1 = axes('parent', featureBasedImageRegistrationParent, ...
	'Units', 'normalized', ...
	'Position', [objpos(1) vobjpos(1) objdim vobjdim], ...
	'Tag', 'featureBasedImageRegistrationAxes1', ...
	'LineWidth', 0.500, ...
	'FontName', 'Helvetica', ...
	'FontSize', 10, ...
	'FontUnits', 'points', ...
	'FontWeight', 'normal', ...
	'FontAngle', 'normal', ...
	'Color', [1 1 1], ...
	'DataAspectRatio', [1 1 1]);
ax1String = uicontrol(featureBasedImageRegistrationParent, ...
	'style', 'text', ...
	'Units', 'normalized', ...
	'string', 'Image 1', ...
	'Position', [objpos(1) 0.925 objdim 0.03], ...
	'foregroundcolor', 'k', ...
	'backgroundcolor', bgColor, ...
	'Fontweight', 'bold', ...
	'Fontsize', defaultFontsize);
%
axes2 = axes('parent', featureBasedImageRegistrationParent, ...
	'Units', 'normalized', ...
	'Position', [objpos(2) vobjpos(1) objdim vobjdim], ...
	'Tag', 'featureBasedImageRegistrationAxes2', ...
	'LineWidth', 0.500, ...
	'FontName', 'Helvetica', ...
	'FontSize', 10, ...
	'FontUnits', 'points', ...
	'FontWeight', 'normal', ...
	'FontAngle', 'normal', ...
	'Color', [1 1 1], ...
	'DataAspectRatio', [1 1 1]);
ax2String = uicontrol(featureBasedImageRegistrationParent, ...
	'style', 'text', ...
	'Units', 'normalized', ...
	'string', 'Image 2', ...
	'Position', [objpos(2) 0.925 objdim 0.03], ...
	'foregroundcolor', 'k', ...
	'backgroundcolor', bgColor, ...
	'Fontweight', 'bold', ...
	'Fontsize', defaultFontsize);
%
axes3 = axes('parent', featureBasedImageRegistrationParent, ...
	'Units', 'normalized', ...
	'Position', [objpos(1) vobjpos(2) objdim vobjdim], ...[objpos(1) vobjpos(2) 0.99-objpos(1) vobjdim], ...
	'Tag', 'featureBasedImageRegistrationAxes3', ...
	'LineWidth', 0.500, ...
	'FontName', 'Helvetica', ...
	'FontSize', 10, ...
	'FontUnits', 'points', ...
	'FontWeight', 'normal', ...
	'FontAngle', 'normal', ...
	'Color', [1 1 1], ...
	'DataAspectRatio', [1 1 1]);
axis off;
uicontrol(featureBasedImageRegistrationParent, ...
	'style', 'text', ...
	'Units', 'normalized', ...
	'string', 'Results (Processes may be stochastic;repeating analysis may yield different results)', ...
	'Position', [0.455 vobjpos(2)+vobjdim+0.01 0.99-0.455 0.03], ...[objpos(1) vobjpos(2)+vobjdim+0.01 0.99-objpos(1) 0.03], ...
	'foregroundcolor', 'k', ...
	'horizontalalignment', 'center', ...
	'backgroundcolor', bgColor, ...
	'Fontweight', 'bold', ...
	'Fontsize', defaultFontsize+2);
%
axes4 = axes('parent', featureBasedImageRegistrationParent, ...
	'Units', 'normalized', ...
	'Position', [objpos(2) vobjpos(2) objdim vobjdim], ...[objpos(1) vobjpos(2) 0.99-objpos(1) vobjdim], ...
	'Tag', 'featureBasedImageRegistrationAxes4', ...
	'LineWidth', 0.500, ...
	'FontName', 'Helvetica', ...
	'FontSize', 10, ...
	'FontUnits', 'points', ...
	'FontWeight', 'normal', ...
	'FontAngle', 'normal', ...
	'Color', [1 1 1], ...
	'DataAspectRatio', [1 1 1]);
axis off;
%
cla(axes1);
imshow(fixed, 'parent', axes1);
set(axes1, 'XLim', 0.5+[0 size(fixed, 2)], 'YLim', 0.5+[0 size(fixed, 1)]);
expandAxes(axes1);
cla(axes2);
imshow(moving, 'parent', axes2);
set(axes2, 'XLim', 0.5+[0 size(moving, 2)], 'YLim', 0.5+[0 size(moving, 1)]);
expandAxes(axes2);
%
panelHeight = get(registerAlignPanel, 'position');
panelHeight = panelHeight(2)-0.015;
commentPanel = uipanel(featureBasedImageRegistrationParent, ...
	'bordertype', 'etchedin', ...
	'title', 'COMMENTS', ...
	'backgroundcolor', bgColor, ...
	'fontsize', defaultFontsize+2, ...
	'foregroundcolor', highlightColor, ...
	'fontweight', 'bold', ...
	'units', 'normalized', ...
	'position', [0.005 0.01 0.415+0.025 panelHeight]);
commentBox = uicontrol(commentPanel, ...
	'style', 'listbox', ...
	'units', 'normalized', ...
	'position', [0.01 0.025 0.99 0.95], ...
	'backgroundcolor', bgColor, ...
	'foregroundcolor', 'k', ...
	'fontsize', defaultFontsize+2, ...
	'max', 10, 'min', 1, ...
	'horizontalalignment', 'l', ...
	'string', '');

% % For setting up DEM/SHOW/REG graphic in PPT:
% set([registerAlignPanel, uipanel1, uipanel2, uipanel3, uipanel4, uipanel5], 'units', 'inches')
% MainPanelPos = registerAlignPanel.Position;
% P{1} = uipanel1.Position;
% P{2} = uipanel2.Position;
% P{3} = uipanel3.Position;
% P{4} = uipanel4.Position;
% P{5} = uipanel5.Position;
% ACROSS = MainPanelPos(2)+MainPanelPos(4)-[P{1}(2)+P{1}(4) P{2}(2)+P{2}(4) P{3}(2)+P{3}(4) P{4}(2)+P{4}(4) P{5}(2)+P{5}(4)]
% WIDTH = [P{1}(4) P{2}(4) P{3}(4) P{4}(4) P{5}(4)]

% % LISTENERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Add "listeners" for featureType Radio Buttons
% % UPDATE UICONTROLS
% allButtons = [FTButtons;
% 	extractorTypeButtons;
% 	rawOrFilteredButtons;
% 	transformTypeButtons];
% for ii = 1:length(allButtons)
% 	%addlistener(allButtons(ii), 'Value', 'PostSet', @updateUIControl);
% 	iptaddcallback(allButtons(ii), 'Callback', @updateUIControl);
% end
% allButtons = [putativeMatchingButtons;
% 	matchingTypeButtons;
% 	registrationDisplayButtons];
% for ii = 1:length(allButtons)
% 	%addlistener(allButtons(ii), 'Value', 'PostSet', @updateUIControl);
% 	iptaddcallback(allButtons(ii), 'Callback', {@updateUIControl, true});
% end
% LISTENERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

tmp = findall(featureBasedImageRegistrationParent, 'style', 'slider');
for ii = 1:numel(tmp)
	set(tmp(ii), ...
		'backgroundcolor', softenValue*get(tmp(ii), 'backgroundcolor'));
end
tmp = findall(featureBasedImageRegistrationParent, 'style', 'edit');
for ii = 1:numel(tmp)
	set(tmp(ii), ...
		'backgroundcolor', min([1 1 1], softenValue*get(tmp(ii), 'backgroundcolor')));
end
tmp = findall(featureBasedImageRegistrationParent, 'style', 'listbox');
for ii = 1:numel(tmp)
	set(tmp(ii), ...
		'backgroundcolor', min([1 1 1], softenValue*get(tmp(ii), 'backgroundcolor')));
end

% Get and store current settings as default values for all uicontrols;
% useful for resetting
allDefaults = snapshot;
% Initial Update:
CVOperation

set(featureBasedImageRegistrationParent, 'visible', 'on', ...
	'handleVisibility', 'callback');
set(featureBasedImageRegistrationParent, 'visible', 'on');
if nargout < 1
	clear featureBasedImageRegistrationParentHandle
end

% START NESTED FUNCTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	function acknowledgements(varargin)
		set(gcbo, 'state', 'off')
		throwComment('');
		throwComment('Thanks to Witek Jachimczyk, Valerie Leung, Dima Lisin, Grant Martin, and Roland Michaely')
		throwComment('for their input, design considerations, and code review.', 1)
	end %acknowledgements

	function addDocButton(parent, docRef, location, color)
		if nargin < 3 || isempty(location)
			location = 'lowerleft';
		end
		if nargin < 4
			%color = imcomplement(get(parent, 'backgroundcolor'));
			try
				color = get(parent, 'backgroundcolor')*0.85;
			catch
				color = 0.5*[1 1 1];
			end
		end
		onePix = pixToPct(parent, [1 1]);
		sz = 16;
		location = lower(location);
		switch location
			case 'lowerleft'
				pos = [-onePix(1) -onePix(2)*2 onePix(1)*sz onePix(2)*1.25*sz];
			case 'lowerright'
				pos = [1-onePix(1)*sz -onePix(2)*2 onePix(1)*sz onePix(2)*1.25*sz];
			case 'upperleft'
				pos = [-onePix(1) 1-onePix(2)*1.25*sz onePix(1)*sz onePix(2)*1.25*sz];
			case 'upperright'
				pos = [1-onePix(1)*sz 1-onePix(2)*1.25*sz onePix(1)*sz onePix(2)*1.25*sz];
			otherwise
				error('addDocButton: unrecognized ''location'' specification.');
		end
		tmp = uicontrol(parent, ...
			'style', 'pushbutton', ...
			'units', 'normalized', ...
			'position', pos, ...
			'backgroundcolor', color, ...
			'string', '?', ...
			'foregroundcolor', 'w', ...
			'fontsize', 7, ...
			'fontweight', 'b', ...
			'tag', 'autoDocButton', ...
			'tooltipstring', ['Doc ' docRef], ...
			'callback', {@getDoc, docRef});
		function getDoc(varargin)
			doc(varargin{3})
		end
	end %addDocButton

	function closetimer(varargin)
		t = timerfindall('TimerFcn', @flickerResults);
		if ~isempty(t)
			stop(t);
			delete(t);
		end
	end %closetimer

	function CVOperation(hObj, varargin)
		% DEM/Show/Register;
		% Update Axes Strings
		if (nargin == 0 && get(registerImmediatelyCheckbox, 'value')) || (nargin ~= 0 && hObj == registerNowButton)
			inliers1 = [];inliers2 = [];
			% enableDisableUIControls
			% DETECTION
			detectFeatures
            if isempty(features1) || isempty(features2)
                if soundOn
                    play(notification)
                end
                registered = moving;
                updateImageAxes(4)
                throwComment('Empty features vector')
                set(ax1String, 'string', sprintf('Image 1 (%d x %d): %d Features Detected', size(fixed, 1), size(fixed, 2), features1.Count))
                set(ax2String, 'string', sprintf('Image 2 (%d x %d): %d Features Detected', size(moving, 1), size(moving, 2), features2.Count))
                showFeatures(1, 2)
                return
            end
			% EXTRACTION
			extractFeaturesFromDetections
			% MATCHING
			matchExtractedFeatures
			% UPDATE VISUALIZATIONS
			updateImageAxes(1);
			updateImageAxes(2);
			% VISUALIZATION
			showFeatures
			% THEN...
			rawOrFiltered = get(get(rawOrFilteredBG, 'SelectedObject'), 'tag');
			if strcmp(rawOrFiltered, 'Include Outliers')
				updateImageAxes(3);
			end
			registerImages
			if ~strcmp(rawOrFiltered, 'Include Outliers')
				updateImageAxes(3);
			end
			verbose = get(verboseCheckbox, 'value');
			if verbose %DISPLAY RESULTS
				home;
				disp('%% DETECT')
				disp(detectString1)
				disp(detectString2)
				disp('%% EXTRACT')
				disp(extractString1)
				disp(extractString2)
				disp('%% MATCH')
				disp(matchString)
				disp('%% CALCULATE TFORM')
				disp(thenString)
				disp('%% REGISTER')
				disp(registerString)
				disp('%% DISPLAY')
				disp(displayString)
			end
			set(ax1String, 'string', ...
				sprintf('Image 1 (%d x %d): %d Features Detected\n(%d Matched Features)', size(fixed, 1), size(fixed, 2), features1.Count, size(index_pairs, 1)))
			set(ax2String, 'string', ...
				sprintf('Image 2 (%d x %d): %d Features Detected\n(%d Matched Features)', size(moving, 1), size(moving, 2), features2.Count, size(index_pairs, 1)))
		end
	end %CVOperation

	function detectFeatures(varargin)
		% Detect features in both images
		switch selectedFeatureType
			case 'SURF'
				SURFMetricThreshold1 = get(SURFMetricThresholdSlider(1), 'value');
				SURFMetricThreshold2 = get(SURFMetricThresholdSlider(2), 'value');
				NumSURFOctaves1 = round(get(NumSURFOctavesSlider(1), 'value'));
				NumSURFOctaves2 = round(get(NumSURFOctavesSlider(2), 'value'));
				NumSURFScaleLevels1 = round(get(NumSURFScaleLevelsSlider(1), 'value'));
				NumSURFScaleLevels2 = round(get(NumSURFScaleLevelsSlider(2), 'value'));
				features1 = detectSURFFeatures(fixed, ...
					'MetricThreshold', SURFMetricThreshold1, ...
					'NumOctaves', NumSURFOctaves1, ...
					'NumScaleLevels', NumSURFScaleLevels1);
				features2 = detectSURFFeatures(moving, ...
					'MetricThreshold', SURFMetricThreshold2, ...
					'NumOctaves', NumSURFOctaves2, ...
					'NumScaleLevels', NumSURFScaleLevels2);
				detectString1 = sprintf('features1 = detectSURFFeatures(fixed, ....\n\t''MetricThreshold'', %0.3f, ...\n\t''NumOctaves'', %d, ...\n\t''NumScaleLevels'', %d);', ...
					SURFMetricThreshold1, NumSURFOctaves1, NumSURFScaleLevels1);
				detectString2 = sprintf('features2 = detectSURFFeatures(moving, ....\n\t''MetricThreshold'', %0.3f, ...\n\t''NumOctaves'', %d, ...\n\t''NumScaleLevels'', %d);', ...
					SURFMetricThreshold2, NumSURFOctaves2, NumSURFScaleLevels2);
			case 'MSER'
				MSERThresholdDelta1 = get(MSERThresholdDeltaSlider(1), 'value');
				MSERThresholdDelta2 = get(MSERThresholdDeltaSlider(2), 'value');
				MinMSERArea1 = round(str2double(get(MinMSERAreaEdit(1), 'string')));
				MaxMSERArea1 = round(str2double(get(MaxMSERAreaEdit(1), 'string')));
				MinMSERArea2 = round(str2double(get(MinMSERAreaEdit(2), 'string')));
				MaxMSERArea2 = round(str2double(get(MaxMSERAreaEdit(2), 'string')));
				if MinMSERArea1 > MaxMSERArea1
					throwComment('MinMSERArea1 must be less than MaxMSERArea1!', 1);
					return
				end
				if MinMSERArea2 > MaxMSERArea2
					throwComment('MinMSERArea2 must be less than MaxMSERArea2!', 1);
					return
				end
				MSERMaxAreaVariation1 = get(MSERMaxAreaVariationSlider(1), 'value');
				MSERMaxAreaVariation2 = get(MSERMaxAreaVariationSlider(2), 'value');
				features1 = detectMSERFeatures(fixed, ...
					'ThresholdDelta', MSERThresholdDelta1, ...
					'RegionAreaRange', [MinMSERArea1 MaxMSERArea1], ...
					'MaxAreaVariation', MSERMaxAreaVariation1);
				features2 = detectMSERFeatures(moving, ...
					'ThresholdDelta', MSERThresholdDelta2, ...
					'RegionAreaRange', [MinMSERArea2 MaxMSERArea2], ...
					'MaxAreaVariation', MSERMaxAreaVariation2);
				detectString1 = sprintf('features1 = detectMSERFeatures(fixed, ....\n\t''ThresholdDelta'', %0.4f, ...\n\t''RegionAreaRange'', [%0.3f %0.3f], ...\n\t''MaxAreaVariation'', %0.3f);', ...
					MSERThresholdDelta1, MinMSERArea1, MaxMSERArea1, MSERMaxAreaVariation1);
				detectString2 = sprintf('features2 = detectMSERFeatures(moving, ....\n\t''ThresholdDelta'', %0.4f, ...\n\t''RegionAreaRange'', [%0.3f %0.3f], ...\n\t''MaxAreaVariation'', %0.3f);', ...
					MSERThresholdDelta2, MinMSERArea2, MaxMSERArea2, MSERMaxAreaVariation2);
			case 'Harris (Corner)'
				MinHarrisQuality1 = get(MinHarrisQualitySlider(1), 'value');
				MinHarrisQuality2 = get(MinHarrisQualitySlider(2), 'value');
				HarrisFilterSize1 = get(HarrisFilterSizeSlider(1), 'value');
				HarrisFilterSize2 = get(HarrisFilterSizeSlider(2), 'value');
				roiPos = rectPos1;
				features1 = detectHarrisFeatures(fixed, ...
					'MinQuality', MinHarrisQuality1, ...
					'FilterSize', HarrisFilterSize1, ...
					'ROI', roiPos);
				detectString1 = sprintf('features1 = detectHarrisFeatures(fixed, ....\n\t''MinQuality'', %0.3f, ...\n\t''FilterSize'', %d, ...\n\t''ROI'', [%d %d %d %d]);', ...
					MinHarrisQuality1, HarrisFilterSize1, roiPos(1), roiPos(2), roiPos(3), roiPos(4));
				roiPos = rectPos2;
				features2 = detectHarrisFeatures(moving, ...
					'MinQuality', MinHarrisQuality2, ...
					'FilterSize', HarrisFilterSize2, ...
					'ROI', roiPos);
				detectString2 = sprintf('features2 = detectHarrisFeatures(moving, ....\n\t''MinQuality'', %0.3f, ...\n\t''FilterSize'', %d, ...\n\t''ROI'', [%d %d %d %d]);', ...
					MinHarrisQuality2, HarrisFilterSize2, roiPos(1), roiPos(2), roiPos(3), roiPos(4));
			case 'Min Eigen (Corner)'
				MinEigenQuality1 = get(MinEigenQualitySlider(1), 'value');
				MinEigenQuality2 = get(MinEigenQualitySlider(2), 'value');
				EigenFilterSize1 = get(EigenFilterSizeSlider(1), 'value');
				EigenFilterSize2 = get(EigenFilterSizeSlider(2), 'value');
				roiPos = rectPos1;
				features1 = detectMinEigenFeatures(fixed, ...
					'MinQuality', MinEigenQuality1, ...
					'FilterSize', EigenFilterSize1, ...
					'ROI', roiPos);
				roiPos = rectPos2;
				detectString1 = sprintf('features1 = detectMinEigenFeatures(fixed, ....\n\t''MinQuality'', %0.3f, ...\n\t''FilterSize'', %0.1f, ...\n\t''ROI'', [%d %d %d %d]);', ...
					MinEigenQuality1, EigenFilterSize1, roiPos(1), roiPos(2), roiPos(3), roiPos(4));
				features2 = detectMinEigenFeatures(moving, ...
					'MinQuality', MinEigenQuality2, ...
					'FilterSize', EigenFilterSize2, ...
					'ROI', roiPos);
				detectString2 = sprintf('features2 = detectMinEigenFeatures(moving, ....\n\t''MinQuality'', %0.3f, ...\n\t''FilterSize'', %0.1f, ...\n\t''ROI'', [%d %d %d %d]);', ...
					MinEigenQuality2, EigenFilterSize2, roiPos(1), roiPos(2), roiPos(3), roiPos(4));
			case 'FAST (Corner)'
				MinFASTQuality1 = get(MinFASTQualitySlider(1), 'value');
				MinFASTQuality2 = get(MinFASTQualitySlider(2), 'value');
				MinFASTContrast1 = get(MinFASTContrastSlider(1), 'value');
				MinFASTContrast2 = get(MinFASTContrastSlider(2), 'value');
				roiPos = rectPos1;
				features1 = detectFASTFeatures(fixed, ...
					'MinQuality', MinFASTQuality1, ...
					'MinContrast', MinFASTContrast1, ...
					'ROI', roiPos);
				roiPos = rectPos2;
				detectString1 = sprintf('features1 = detectFASTFeatures(fixed, ....\n\t''MinQuality'', %0.3f, ...\n\t''MinContrast'', %0.3f, ...\n\t''ROI'', [%d %d %d %d]);', ...
					MinFASTQuality1, MinFASTContrast1, roiPos(1), roiPos(2), roiPos(3), roiPos(4));
				features2 = detectFASTFeatures(moving, ...
					'MinQuality', MinFASTQuality2, ...
					'MinContrast', MinFASTContrast2, ...
					'ROI', roiPos);
				detectString2 = sprintf('features2 = detectFASTFeatures(moving, ....\n\t''MinQuality'', %0.3f, ...\n\t''MinContrast'', %0.3f, ...\n\t''ROI'', [%d %d %d %d]);', ...
					MinFASTQuality2, MinFASTContrast2, roiPos(1), roiPos(2), roiPos(3), roiPos(4));
			case 'BRISK (Corner)'
				minBRISKQuality1 = get(MinBRISKQualitySlider(1), 'value');
				minBRISKQuality2 = get(MinBRISKQualitySlider(2), 'value');
				minBRISKContrast1 = get(minBRISKContrastSlider(1), 'value');
				minBRISKContrast2 = get(minBRISKContrastSlider(2), 'value');
				numBRISKOctaves1 = str2double(BriskOctavesOptions...
					{get(numBRISKOctavesListbox(1), 'value')});
				numBRISKOctaves2 = str2double(BriskOctavesOptions...
					{get(numBRISKOctavesListbox(2), 'value')});
				roiPos = rectPos1;
				features1 = detectBRISKFeatures(fixed, ...
					'MinQuality', minBRISKQuality1, ...
					'MinContrast', minBRISKContrast1, ...
					'NumOctaves', numBRISKOctaves1, ...
					'ROI', roiPos);
				detectString1 = sprintf('features1 = detectBRISKFeatures(fixed, ....\n\t''MinQuality'', %0.3f, ...\n\t''MinContrast'', %0.3f, ...\n\t''NumOctaves'', %i, ...\n\t''ROI'', [%d %d %d %d]);', ...
					minBRISKQuality1, minBRISKContrast1, numBRISKOctaves1, roiPos(1), roiPos(2), roiPos(3), roiPos(4));
				roiPos = rectPos2;
				features2 = detectBRISKFeatures(moving, ...
					'MinQuality', minBRISKQuality2, ...
					'MinContrast', minBRISKContrast2, ...
					'NumOctaves', numBRISKOctaves2, ...
					'ROI', roiPos);
				detectString2 = sprintf('features2 = detectBRISKFeatures(moving, ....\n\t''MinQuality'', %0.3f, ...\n\t''MinContrast'', %0.3f, ...\n\t''NumOctaves'', %i, ...\n\t''ROI'', [%d %d %d %d]);', ...
					minBRISKQuality2, minBRISKContrast2, numBRISKOctaves2, roiPos(1), roiPos(2), roiPos(3), roiPos(4));
		end
	end %detectFeatures

	function exportResults(varargin)
		try %#ok<*TRYNC>
			set(gcbo, 'state', 'off');
		end
		home;
		disp('%% DETECT')
		disp(detectString1)
		disp(detectString2)
		disp('%% EXTRACT')
		disp(extractString1)
		disp(extractString2)
		disp('%% MATCH')
		disp(matchString)
		disp('%% CALCULATE TFORM')
		disp(thenString)
		disp('%% REGISTER')
		disp(registerString)
		disp('%% DISPLAY')
		disp(displayString)
		throwComment('MATLAB Code written to Command Window.')
        if 1
            if soundOn
                play(notification)
            end
            varname1 = evalin('base', 'genvarname(''Registered'', who)');
            assignin('base', varname1, registered);
            throwComment(sprintf('Registered image written to Base Workspace as ''%s.''', varname1), 0);
            fprintf('\n***\nRegistered image written to Base Workspace as ''%s.''\n***\n', varname1);
            varname2 = evalin('base', 'genvarname(''tform'', who)');
            assignin('base', varname2, tform)
            throwComment(sprintf('TFORM written to Base Workspace as ''%s.''', varname2), 0);
            fprintf('\n***\nRegistered image written to Base Workspace as ''%s.''\n***\n', varname2);
        end
	end %exportResults

	function extractFeaturesFromDetections(varargin)
		if isempty(features1) || isempty(features2)
			registered = moving;
			updateImageAxes(4)
			throwComment('Empty features vector.')
			return
		end
		% Extract feature descriptors
		if strcmp(selectedExtractorType, 'HOG')
			HOGCellSize1 = str2double(get(HOGCellSize1Edit, 'string'));
			HOGCellSize2 = str2double(get(HOGCellSize2Edit, 'string'));
			HOGBlockSize1 = str2double(get(HOGBlockSize1Edit, 'string'));
			HOGBlockSize2 = str2double(get(HOGBlockSize2Edit, 'string'));
			HOGBlockOverlap1 = str2double(get(HOGBlockOverlap1Edit, 'string'));
			HOGBlockOverlap2 = str2double(get(HOGBlockOverlap2Edit, 'string'));
			numHOGBins = str2double(get(numHOGBinsEdit, 'string'));
			UseSignedOrientation = get(UseSignedOrientationCheckbox, 'value');
			[descriptors1, validPoints1]  = extractHOGFeatures(fixed, features1, ...
				'CellSize', [HOGCellSize1 HOGCellSize2], ...
				'BlockSize', [HOGBlockSize1 HOGBlockSize2], ...
				'BlockOverlap', [HOGBlockOverlap1 HOGBlockOverlap2], ...
				'NumBins', numHOGBins, ...
				'UseSignedOrientation', UseSignedOrientation);
			[descriptors2, validPoints2]  = extractHOGFeatures(moving, features2, ...
				'CellSize', [HOGCellSize1 HOGCellSize2], ...
				'BlockSize', [HOGBlockSize1 HOGBlockSize2], ...
				'BlockOverlap', [HOGBlockOverlap1 HOGBlockOverlap2], ...
				'NumBins', numHOGBins, ...
				'UseSignedOrientation', UseSignedOrientation);
			extractString1 = sprintf('[descriptors1, validPoints1] = extractHOGFeatures(fixed, features1, ...\n\t''CellSize'', [%d %d], ...\n\t''BlockSize'', [%d %d], ...\n\t''BlockOverlap'', [%d %d], ...\n\t''NumBins'', %d, ...\n\t''UseSignedOrientation'', %d);', ...
				HOGCellSize1, HOGCellSize2, ...
				HOGBlockSize1, HOGBlockSize2, ...
				HOGBlockOverlap1, HOGBlockOverlap2, ...
				numHOGBins, UseSignedOrientation);
			extractString2 = sprintf('[descriptors2, validPoints2] = extractHOGFeatures(moving, features2, ...\n\t''CellSize'', [%d %d], ...\n\t''BlockSize'', [%d %d], ...\n\t''BlockOverlap'', [%d %d], ...\n\t''NumBins'', %d, ...\n\t''UseSignedOrientation'', %d);', ...
				HOGCellSize1, HOGCellSize2, ...
				HOGBlockSize1, HOGBlockSize2, ...
				HOGBlockOverlap1, HOGBlockOverlap2, ...
				numHOGBins, UseSignedOrientation);
		else
			BlockSize = round(get(blockSliderUIControl(1), 'value'));
			BlockSize = floor(BlockSize);
			if ~isodd(BlockSize)
				BlockSize = BlockSize + 1;
				set(blockSliderUIControl(1), 'value', BlockSize);
				set(blockSliderUIControl(2), 'string', num2str(BlockSize));
			end
			%tmp = get(SURFSizeListbox, 'string');
			SURFSize = str2double(SURFSizeOpts{get(SURFSizeListbox, 'value')});
			[descriptors1, validPoints1]  = extractFeatures(fixed, features1, ...
				'Method', selectedExtractorType, ...
				'BlockSize', BlockSize, ...
				'SURFSize', SURFSize);
			[descriptors2, validPoints2]  = extractFeatures(moving, features2, ...
				'Method', selectedExtractorType, ...
				'BlockSize', BlockSize, ...
				'SURFSize', SURFSize);
			extractString1 = sprintf('[descriptors1, validPoints1] = extractFeatures(fixed, features1, ...\n\t''Method'', ''%s'', ...\n\t''BlockSize'', %d, ...\n\t''SURFSize'', %d);', selectedExtractorType, BlockSize, SURFSize);
			extractString2 = sprintf('[descriptors2, validPoints2] = extractFeatures(moving, features2, ...\n\t''Method'', ''%s'', ...\n\t''BlockSize'', %d, ...\n\t''SURFSize'', %d);', selectedExtractorType, BlockSize, SURFSize);
		end
	end %extractFeaturesFromDetections

	function flickerFaster(varargin)
		t = timerfindall('TimerFcn', @flickerResults);
		if ~isempty(t)
			stop(t);
			flickerFrequency = 1/(get(t, 'Period')*0.8);
			set(StartButton, 'cdata', pauseIcon);
			throwComment(sprintf('Setting flicker frequency to %0.3f Hz.', flickerFrequency));
			set(t, 'Period', 1/flickerFrequency)
			start(t);
		end
	end %flickerFaster

	function flickerSlower(varargin)
		t = timerfindall('TimerFcn', @flickerResults);
		if ~isempty(t)
			stop(t);
			flickerFrequency = 1/(get(t, 'Period')*1.2);
			set(StartButton, 'cdata', pauseIcon);
			throwComment(sprintf('Setting flicker frequency to %0.3f Hz.', flickerFrequency));
			set(t, 'Period', 1/flickerFrequency)
			start(t);
		end
	end %flickerSlower

	function flickerResults(varargin)
		try
			set(StartButton, 'cdata', pauseIcon);
			currDisp = getappdata(featureBasedImageRegistrationParent, 'CurrDisp');
			if isempty(currDisp)
				currDisp = 'Fixed';
			end
			if strcmp(currDisp, 'Fixed')
				setappdata(featureBasedImageRegistrationParent, 'CurrDisp', 'Registered');
				imshow(registered, [], 'parent', axes4);
			else
				setappdata(featureBasedImageRegistrationParent, 'CurrDisp', 'Fixed');
				imshow(fixed, [], 'parent', axes4);
			end
			expandAxes(axes4);
		catch
			throwComment('Stopping flicker timer')
			closetimer
		end
	end %flickerResults

	function GetNewFile(varargin)
		set(gcbo, 'state', 'off');
		tmp = sprintf('Image 1 (''Fixed/Left'') or Image 2 (''Moving/Right'')?\n\n(Note: You can FIND and EXTRACT features from a single image, \nbut MATCHING features requires the specification of two images.)');
		imnum = questdlg(tmp, 'Select image target', '1 (''Fixed/Left'')', '2 (''Moving/Right'')', 'Cancel', '1 (''Fixed/Left'')');
		switch imnum
			case '1 (''Fixed/Left'')'
				[fixed, cmap, fname, fpath, userCanceled] = getNewImage(true);
				if userCanceled
					return
				end
				fixedName = fullfile(fpath, fname);
				if ~isempty(cmap)
					fixed = ind2rgb(fixed, cmap);
				end
				% Convert to gray?
				if size(fixed, 3)==3
					fixed = rgb2gray(fixed);
					throwComment('Image 1 converted to grayscale for registration purposes.')
				end
				delete(findall(axes1, 'type', 'hggroup', 'tag', 'imrect'));
				updateSizeInformation(1)
				cla(axes1);
				imshow(fixed, 'parent', axes1);
				set(axes1, 'XLim', 0.5+[0 size(fixed, 2)], 'YLim', 0.5+[0 size(fixed, 1)]);
				expandAxes(axes1);
				updateImageAxes(1);
				updateImageAxes(2);
			case '2 (''Moving/Right'')'
				[moving, cmap, fname, fpath, userCanceled] = getNewImage(true);
				if userCanceled
					return
				end
				movingName = fullfile(fpath, fname);
				if ~isempty(cmap)
					moving = ind2rgb(moving, cmap);
				end
				% Convert to gray?
				if size(moving, 3)==3
					moving = rgb2gray(moving);
					throwComment('Image 2 converted to grayscale for registration purposes.')
				end
				delete(findall(axes2, 'type', 'hggroup', 'tag', 'imrect'));
				updateSizeInformation(2)
				cla(axes2);
				imshow(moving, 'parent', axes2);
				set(axes2, 'XLim', 0.5+[0 size(moving, 2)], 'YLim', 0.5+[0 size(moving, 1)]);
				expandAxes(axes2);
				updateImageAxes(1);
				updateImageAxes(2);
		end
		function updateSizeInformation(imnum)
			switch imnum
				case 1
					rectPos1 = [1 1 size(fixed, 2)-1 size(fixed, 1)-1];
				case 2
					rectPos2 = [1 1 size(moving, 2)-1 size(moving, 1)-1];
			end
		end
	end %GetNewFile

	function initializeCVTool(varargin)
		if singleton && ~isempty(findall(0, 'name', 'featureBasedImageRegistration'))
			delete(findall(0, 'name', 'featureBasedImageRegistration'));%Singleton
		end
		
		if nargin == 0
			fixedName = 'cameraman.tif';
			movingName = 'distortedCameraman.tif';
			fixed = im2double(imread(fixedName));
			try
				moving = im2double(imread(movingName));
			catch
				rect = [52.5 22.5 136 187];
				moving = imcrop(fixed, rect);
				scale = 0.7;
				moving = imresize(moving, scale);% Scale Image
				theta = 30;
				moving = imrotate(moving, theta, 'bicubic');% Rotate Image
			end
		end
		if nargin > 0
			fixed = varargin{1};
			if ischar(fixed)
				[fixed, cmap] = imread(fixed);
				if ~isempty(cmap)
					fixed = ind2rgb(fixed, cmap);
				end
			end
			fixed = im2double(fixed);
			if size(fixed, 3) == 3
				fixed = rgb2gray(fixed);
			end
			% This facilitates a single-image workflow:
			%moving = zeros(round(size(fixed)*0.25));%(MSER fails with Logical)
            moving = fixed;
			%
		end
		
		if nargin > 1
			moving= varargin{2};
			if ischar(moving)
				[moving, cmap] = imread(moving);
				if ~isempty(cmap)
					moving = ind2rgb(moving, cmap);
				end
			end
			moving = im2double(moving);
			if size(moving, 3) == 3
				moving = rgb2gray(moving);
			end
		end
		
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		% INITIALIZATIONS and DEFAULTS:
		validateattributes(fixed, ...
			{'numeric', 'char', 'logical'}, {}, mfilename, 'img', 1);
		validateattributes(moving, ...
			{'numeric', 'char', 'logical'}, {}, mfilename, 'img', 1);
		bgColor = [0.553 0.659 0.678];
		highlightColor = [0.03 0.41 0.62];%*0.85
		colors = bone(20);
		colors = colors(9:end, :);
		softenValue = 1.2;%multiplier for bgcolor of uisliders, uilistboxes, and uiedits
		% Default units
		tmp = get(0, 'screensize');
		if tmp(3) > 1200
			defaultFontsize = 7;
		else
			defaultFontsize = 6;
		end
		a = ver('vision');
		preBRISK = str2double(a.Version) <= 5.3;
		if(verLessThan('matlab', '8.4'))
			buttonGroupChangedFcn = 'SelectionChangeFcn';
		else
			buttonGroupChangedFcn = 'SelectionChangedFcn';
		end
		% Warnings:
		initialWarnState = warning;
		warning('off', 'vision:matchFeatures:maxRatioUnused')
		warning('off', 'vision:matchFeatures:binParamUnused')
		warning('off', 'MATLAB:system:nonRelevantProperty')
		warning('off', 'MATLAB:nearlySingularMatrix')
		warning('off', 'MATLAB:singularMatrix');
		warning('off', 'MATLAB:TIMER:RATEPRECISION')
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	end %initializeCVTool

	function matchExtractedFeatures(varargin)
		% Match features using their descriptors and show results on valid points
		MatchMethod = get(get(matchingMethodBG, 'SelectedObject'), 'tag');
		MatchMetric = matchMetricOpts{get(MatchMetricListbox, 'value')};
		MatchThreshold = get(MatchThresholdSlider, 'value');
		MaxRatio = get(MaxRatioSlider, 'value');
		Prenormalized = get(PrenormalizedCheckbox, 'value');%==1
		[index_pairs, metric] = matchFeatures(descriptors1, descriptors2, ...
			'Method', MatchMethod, ...
			'Metric', MatchMetric, ...
			'MatchThreshold', MatchThreshold, ...
			'MaxRatio', MaxRatio, ...
			'Prenormalized', Prenormalized==1);%#ok metric to be used later
		% Retrieve locations of corresponding points for each image.
		matched1 = validPoints1(index_pairs(:, 1), :);
		matched2 = validPoints2(index_pairs(:, 2), :);
		matchString = sprintf('[index_pairs, metric] = matchFeatures(descriptors1, descriptors2, ...\n\t''Method'', ''%s'', ...\n\t''Metric'', ''%s'', ...\n\t''MatchThreshold'', %0.3f, ...\n\t''MaxRatio'', %0.3f, ...\n\t''Prenormalized'', %d==1);\nmatched1 = validPoints1(index_pairs(:, 1), :);\nmatched2 = validPoints2(index_pairs(:, 2), :);', ...
			MatchMethod, MatchMetric, MatchThreshold, MaxRatio, Prenormalized);
	end %matchExtractedFeatures

	function pctOut = pixToPct(inParent, pixIn)
		% Provide the handle to the parent, and a 2-element vector of W/H (in
		% pixels);this will return the normalized WH....
		if nargin ~= 2
			error('Inappropriate use of pixToPct;requires 2 inputs.')
		end
		if ~ishandle(inParent)
			error('pixToPct: ''inParent'' must be a handle.')
		end
		parentPix = getPix(inParent);
		pctOut = pixIn./parentPix;
		
		function pix = getPix(parent)
			currUnits = get(parent, 'units');
			set(parent, 'units', 'pixels');
			pix = get(parent, 'position');
			pix = pix(3:4);
			set(parent, 'units', currUnits);
		end
	end %pixToPct

	function registerImages(varargin)
		if isempty(matched1) || isempty(matched2)
			registered = moving;
			updateImageAxes(4)
			throwComment('Empty matched-features vector!');
			return
		end
		rawOrFiltered = get(get(rawOrFilteredBG, 'SelectedObject'), 'tag');
		if strcmp(rawOrFiltered, 'Include Outliers')
			updateImageAxes(3);
		end
		transformType = get(get(transformTypeBG, 'SelectedObject'), 'tag');
		MaxNumTrials = round(get(MaxNumTrialsSlider, 'value'));
		Confidence = get(ConfidenceSlider, 'value');
		MaxDistance = get(MaxDistanceSlider, 'value');
		try
			%tic;
			[tform, inliers2, inliers1] = estimateGeometricTransform(matched2, matched1, lower(transformType), ...
				'MaxNumTrials', MaxNumTrials, 'Confidence', Confidence, 'MaxDistance', MaxDistance);
            %t = toc;
			throwComment('Estimation of geometric transform was successful.')
		catch
			if soundOn, play(notification), end
			registered = moving;
			updateImageAxes(4)
			throwComment('Unable to register with these settings.')
			return
		end
		outputView = imref2d(size(fixed));
		registered = imwarp(moving, tform, 'OutputView', outputView);
		registerString = sprintf('outputView = imref2d(size(fixed));\nregistered = imwarp(moving, tform, ''OutputView'', outputView);');
		displayString = sprintf('imshowpair(fixed, registered)');
		if ~strcmp(rawOrFiltered, 'Include Outliers')
			updateImageAxes(3);
		end
		updateImageAxes(4)
		if ~preBRISK
			thenString = sprintf('[tform, inliers2, inliers1] = estimateGeometricTransform(matched2, matched1, ...\n\t''%s'', ...\n\t''MaxNumTrials'', %0.0f, ...\n\t''Confidence'', %f, ...\n\t''MaxDistance'', %f);', lower(transformType), MaxNumTrials, Confidence, MaxDistance);
		else
			thenString = sprintf('[tform, inliers2, inliers1] = estimateGeometricTransform(matched2, matched1, ...\n\t''%s'', ...\n\t''MaxNumTrials'', %0.0f, ...\n\t''Confidence'', %f, ...\n\t''MaxDistance'', single(%f));', lower(transformType), MaxNumTrials, Confidence, MaxDistance);
		end
	end %registerImage

	function resetAndClose(varargin)
		warning(initialWarnState)
		closereq
	end %resetAndClose

	function resetDefaults(varargin)
		try
			set(gcbo, 'state', 'off');
		end
		for index = 1:numel(allDefaults)
			switch get(allUIs(index), 'style')
				case {'slider', 'listbox', 'radiobutton', 'checkbox'}
					set(allUIs(index), 'value', allDefaults{index});
				case {'edit', 'text'}
					set(allUIs(index), 'string', allDefaults{index});
			end
			suppressUpdates = true;
			updateUIControl(allUIs(index), suppressUpdates)
		end
		%Reset flicker frequency to 1 Hz
		flickerFrequency = 1;
		set(StartButton, 'cdata', startIcon)
		rectPos1 = [1 1 size(fixed, 2)-1 size(fixed, 1)-1];
		rectPos2 = [1 1 size(moving, 2)-1 size(moving, 1)-1];
		resetImrects
		CVOperation
		throwComment('All UIs reset to default values!')
	end %resetDefaults

	function resetImrects(varargin)
		% Refresh positions, callbacks of imrects
		delete(findall([axes1, axes2], 'type', 'hggroup', 'tag', 'imrect'))
		if any(strcmp(selectedFeatureType, ...
				{'Harris (Corner)', ...
				'Min Eigen (Corner)', ...
				'FAST (Corner)', ...
				'BRISK (Corner)'}))
			% Axes1 IMRECT
			parentAx = axes1;
			rectPos = rectPos1;
			roi{1} = imrect(parentAx, rectPos); %#ok<*IMRECT> %For now, suppressing this message
			%roi{1} = addROI(parentAx, rectPos);
			fcn = makeConstrainToRectFcn('imrect', ...
				get(parentAx, 'XLim'), ...
				get(parentAx, 'YLim'));
			setPositionConstraintFcn(roi{1}, fcn);%.iptgetapi
			roi{1}.addNewPositionCallback(@(pos) updateRectPos(1));
			% Axes2 IMRECT
			parentAx = axes2;
			rectPos = rectPos2;
			roi{2} = imrect(parentAx, rectPos);
			%roi{2} = addROI(parentAx, rectPos);
			fcn = makeConstrainToRectFcn('imrect', ...
				get(parentAx, 'XLim'), ...
				get(parentAx, 'YLim'));
			setPositionConstraintFcn(roi{2}, fcn);%.iptgetapi
			roi{2}.addNewPositionCallback(@(pos) updateRectPos(2));
		end
		%
		function updateRectPos(opt, varargin)
			switch opt
				case 1
					rectPos1 = roi{opt}.getPosition;
					if verLessThan('matlab', '8.5')
						rectPos1 = round(rectPos1);
					end
				case 2
					rectPos2 = roi{opt}.getPosition;
					if verLessThan('matlab', '8.5')
						rectPos2 = round(rectPos2);
					end
			end
			CVOperation
		end
	end %resetImrects

	function showFeatures(varargin)
		if nargin > 1
			%Update first
			updateImageAxes(1)
			updateImageAxes(2)
		end
		NumStrongest = round(get(NumStrongestSlider, 'value'));
		if NumStrongest == 0 || isempty(features1) || isempty(features2)
			if isempty(features1)
				throwComment('No features detected in image 1.')
			end
			if isempty(features2)
				throwComment('No features detected in image 2.')
			end
			return
		end
		hold(axes1, 'on')
		hold(axes2, 'on');
		if ismember(selectedFeatureType, ...
				{'MSER', 'Harris (Corner)', 'Min Eigen (Corner)', 'FAST (Corner)'})
			% No selectStrongest method for this feature type!
			axes(axes1);
			plot(features1(1:min(NumStrongest, features1.Count)));
			set(findall(axes1, 'type', 'line'), 'tag', 'TemporaryFeaturePlot');
			axes(axes2);
			plot(features2(1:min(NumStrongest, features2.Count)));
			set(findall(axes2, 'type', 'line'), 'tag', 'TemporaryFeaturePlot');
			throwComment('No "selectStrongest" method for this feature type...showing first-detected features instead!')
		else
			axes(axes1);
			plot(features1.selectStrongest(NumStrongest));
			set(findall(axes1, 'type', 'line'), 'tag', 'TemporaryFeaturePlot');
			axes(axes2);
			plot(features2.selectStrongest(NumStrongest));
			set(findall(axes2, 'type', 'line'), 'tag', 'TemporaryFeaturePlot');
		end
	end %showFeatures

	function outVal = snapshot(varargin)
		% Get defaults:
		set(gcbo, 'state', 'off');
		allUIs =  findall(featureBasedImageRegistrationParent, 'type', 'uicontrol');
		outVal = cell(numel(allUIs), 1);
		for index = 1:numel(allUIs)
			switch get(allUIs(index), 'style')
				case {'slider', 'listbox', 'radiobutton', 'checkbox'}
					outVal{index} = get(allUIs(index), 'value');
				case {'edit'}
					outVal{index} = get(allUIs(index), 'string');
			end
		end
	end %snapshot

	function swapImages(varargin)
		set(gcbo, 'state', 'off');
		tmp = fixed;
		fixed = moving;
		moving = tmp;
		tmp = rectPos2;
		rectPos2 = rectPos1;
		rectPos1 = tmp;
		tmp = fixedName;
		fixedName = movingName;
		movingName = tmp;
		cla(axes1);
		imshow(fixed, 'parent', axes1);
		set(axes1, 'XLim', 0.5+[0 size(fixed, 2)], 'YLim', 0.5+[0 size(fixed, 1)]);
		expandAxes(axes1);
		cla(axes2);
		imshow(moving, 'parent', axes2);
		set(axes2, 'XLim', 0.5+[0 size(moving, 2)], 'YLim', 0.5+[0 size(moving, 1)]);
		expandAxes(axes2);
		%Filter Sizes (ensure still within range)
		filterValsToValidate = [HarrisFilterSizeSlider, EigenFilterSizeSlider];
		for kk = 1:numel(filterValsToValidate)
			updateUIControl(filterValsToValidate(kk), true)
		end
		resetImrects
		updateUIControl([])
	end %swapImages

	function throwComment(commentString, beepOn, append)
		if nargin < 2
			beepOn = 0;
		end
		if nargin < 3
			append = 1;
		end
		if append
			currString   = get(commentBox, 'string');
			currString   = char(cellstr({currString;commentString}));
			if all(double(currString(1, :)== 32))
				currString = currString(2:end, :);
			end
			set(commentBox, 'string', currString);
		else
			set(commentBox, 'string', commentString);
		end
		tmp              = size(get(commentBox, 'string'), 1);
		set(commentBox, 'listboxtop', tmp, 'value', tmp);
		
		if beepOn  %&& ~strcmp(soundsOff, 'on')
			if soundOn, play(notification), end
		end
		drawnow;
	end %throwComment

	function toggleSound(varargin)
		set(gcbo, 'state', 'off');
		soundStatus = soundOn;
		if soundStatus
			soundOn = false;
			tmp = imread('noSoundIcon.png');
		else
			soundOn = true;
			tmp = imread('soundIcon.png');
		end
		set(soundOnOffButton, 'cdata', tmp)
		if soundOn, play(notification), end
	end %toggleSound

	function toggleTimerPause(varargin)
		t = timerfindall('TimerFcn', @flickerResults);
		if ~isempty(t)
			if strcmp(get(t, 'Running'), 'on')
				stop(t)
				set(StartButton, 'cdata', startIcon)
			else
				start(t)
				set(StartButton, 'cdata', pauseIcon)
			end
		end
	end %toggleTimerPause

	function toggleTooltipCB(varargin)
		set(gcbo, 'state', 'off');
		status = toggleTooltips(featureBasedImageRegistrationParent);
		throwComment(sprintf('Tooltips turned %s.', status));
		set(toggleTooltipButton, ...
			'Tooltipstring', 'Toggle tooltips on or off.');
	end %toggleTooltipCB

	function updateImageAxes(varargin)
		selection = varargin{nargin};
		keepROI = any(strcmp(selectedFeatureType, ...
			{'Harris (Corner)', ...
			'Min Eigen (Corner)', ...
			'FAST (Corner)', ...
			'BRISK (Corner)'}));
		switch selection
			case 1
				if keepROI
					currImrect = findall(axes1, 'tag', 'imrect');
					allTempItems = setdiff(findall(axes1), ...
						[axes1;imhandles(axes1);findall(currImrect)]);
				else
					allTempItems = setdiff(findall(axes1), ...
						[axes1;imhandles(axes1)]);
				end
				delete(allTempItems);
			case 2
				if keepROI
					currImrect = findall(axes2, 'tag', 'imrect');
					allTempItems = setdiff(findall(axes2), ...
						[axes2;imhandles(axes2);findall(currImrect)]);
				else
					allTempItems = setdiff(findall(axes2), ...
						[axes2;imhandles(axes2)]);
				end
				delete(allTempItems);
			case 3
				if ~isempty(matched1)
					cla(axes3)
					% Show putative point matches.
					putativeMatchMethod = get(get(putativeMatchesBG, 'SelectedObject'), 'tag');
					axes(axes3)
					if ~isempty(inliers1)
						showMatchedFeatures(fixed, moving, inliers1, inliers2, putativeMatchMethod);
					else
						showMatchedFeatures(fixed, moving, matched1, matched2, putativeMatchMethod);
					end
					%set(axes3, 'xlimmode', 'auto', 'ylimmode', 'auto')
					tmp = findall(axes3);
					%set(tmp(end), 'hittest', 'off')
					set(tmp(~strcmp(get(tmp, 'type'), 'image')), 'hittest', 'off');
					expandAxes(axes3);
				end
			case 4
				closetimer;
				%set(StartButton, 'cdata', startIcon)
				if isempty(registered)
					if soundOn, play(notification), end
					throwComment('First register the images!')
					return
				end
				cla(axes4)
				% Show registration.
				axes(axes4)
				registrationDisplayOption = get(get(registrationDisplayOptsBG, 'SelectedObject'), 'tag');
				if strcmp(registrationDisplayOption, 'Flicker')
					set([StartButton, FasterButton, SlowerButton], 'enable', 'on')
					% CREATE AND START TIMER OBJECT, with 1-second (fixed) period
					timerobj = timer('timerfcn', @flickerResults, ...
						'period', flickerFrequency, ...
						'executionmode', 'fixedrate');
					start(timerobj);
				elseif strcmp(registrationDisplayOption, 'CheckerBoard')
					set([StartButton, FasterButton, SlowerButton], 'enable', 'off')
					chkrbd = checkerboard(max(ceil(size(registered)/8)));
					chkrbd = chkrbd > 0.5;%Convert to binary
					chkrbd = chkrbd(1:size(registered, 1), 1:size(registered, 2));
					imshow(fixed, [], 'parent', axes4);
					hold on
					AlignedImageObj = imshow(registered, [], 'parent', axes4);
					set(AlignedImageObj, 'alphadata', chkrbd);
				else
					set([StartButton, FasterButton, SlowerButton], 'enable', 'off')
					imshowpair(fixed, registered, 'method', registrationDisplayOption);
					% I calculate imf just to determin xlim and ylim of axes4.
					% (There's likely a better way to do that.)
					imf = imfuse(fixed, registered, ...
						'method', registrationDisplayOption);
					set(axes4, 'xlim', 0.5+[0 size(imf, 2)], 'ylim', 0.5+[0 size(imf, 1)])
				end
				expandAxes(axes4);
		end
	end %updateImageAxes

	function updateUIControl(hObj, suppressUpdate, varargin)
		% Refresh & Validate UIControl-Mediated Values;
		% Refresh Feature-Type Panel
		% Refresh Extractor Panel
		% Trigger Update of DEM/Show/Register (if requested)
		if nargin ~= 0
			hObjTag = get(hObj, 'tag');
		end
		if isempty(hObjTag), hObjTag = '';end
		if nargin < 2 || ~islogical(suppressUpdate)
			suppressUpdate = false;
		elseif nargin > 2
			suppressUpdate = varargin{1};
		end
		% Ensure filterSize complies with constraints
		switch hObjTag
			case 'HarrisFilterSize1'
				% [3, min(size(I))]
				HarrisFilterSize1 = get(hObj, 'value');
				HarrisFilterSize1 = round(HarrisFilterSize1);
				HarrisFilterSize1 = min(HarrisFilterSize1, min(size(fixed)));
				if ~isodd(HarrisFilterSize1)
					HarrisFilterSize1 = HarrisFilterSize1 - 1;
				end
				set(HarrisFilterSizeSlider(1), 'value', HarrisFilterSize1);
				set(HarrisFilterSizeEdit(1), 'string', num2str(HarrisFilterSize1));
			case 'HarrisFilterSize2'
				HarrisFilterSize2 = get(hObj, 'value');
				HarrisFilterSize2 = round(HarrisFilterSize2);
				HarrisFilterSize2 = min(HarrisFilterSize2, min(size(moving)));
				if ~isodd(HarrisFilterSize2)
					HarrisFilterSize2 = HarrisFilterSize2 - 1;
				end
				set(HarrisFilterSizeSlider(2), 'value', HarrisFilterSize2);
				set(HarrisFilterSizeEdit(2), 'string', num2str(HarrisFilterSize2));
			case 'EigenFilterSize1'
				EigenFilterSize1 = get(hObj, 'value');
				EigenFilterSize1 = round(EigenFilterSize1);
				EigenFilterSize1 = min(EigenFilterSize1, min(size(fixed)));
				if ~isodd(EigenFilterSize1)
					EigenFilterSize1 = EigenFilterSize1 - 1;
				end
				set(EigenFilterSizeSlider(1), 'value', EigenFilterSize1);
				set(EigenFilterSizeEdit(1), 'string', num2str(EigenFilterSize1));
			case 'EigenFilterSize2'
				EigenFilterSize2 = get(hObj, 'value');
				EigenFilterSize2 = round(EigenFilterSize2);
				EigenFilterSize2 = min(EigenFilterSize2, min(size(moving)));
				if ~isodd(EigenFilterSize2)
					EigenFilterSize2 = EigenFilterSize2 - 1;
				end
				set(EigenFilterSizeSlider(2), 'value', EigenFilterSize2);
				set(EigenFilterSizeEdit(2), 'string', num2str(EigenFilterSize2));
		end
		if ismember(hObj, linkages)
			linkProps12 = get(linkpropsCheckbox, 'value');
			if linkProps12
				drawnow;%Make sure sliderPanel is updated
				cols = [1, 2];
				% objSource = hObj
				% sourceStyle = get(hObj, 'style');
				[r, c] = find(ismember(linkages, hObj));
				if ~isempty(r)
					switch(get(hObj, 'style'))
						case {'slider', 'listbox'}
							prop = 'Value';
						case {'edit', 'text'}
							prop = 'String';
					end
					colPos = setdiff(cols, c);
					set(linkages(r, colPos), prop, get(hObj, prop));
					% Special handling for edit boxes of sliderPanels
					textTarget = [];
					fmt = '%0.2f';
					if ismember(hObj, MSERThresholdDeltaSlider)
						textTarget = MSERThresholdDeltaEdit(colPos);
					elseif ismember(hObj, MSERMaxAreaVariationSlider)
						textTarget = MSERMaxAreaVariationEdit(colPos);
					elseif ismember(hObj, SURFMetricThresholdSlider)
						textTarget = SURFMetricThresholdEdit(colPos);
						fmt = '%0.0f';
					elseif ismember(hObj, NumSURFOctavesSlider)
						textTarget = NumSURFOctavesEdit(colPos);
						fmt = '%0.0f';
					elseif ismember(hObj, NumSURFScaleLevelsSlider)
						textTarget = NumSURFScaleLevelsEdit(colPos);
						fmt = '%0.0f';
					elseif ismember(hObj, MinHarrisQualitySlider)
						textTarget = MinHarrisQualityEdit(colPos);
					elseif ismember(hObj, HarrisFilterSizeSlider)
						textTarget = HarrisFilterSizeEdit(colPos);
					elseif ismember(hObj, MinEigenQualitySlider)
						textTarget = MinEigenQualityEdit(colPos);
						fmt = '%0.3f';
					elseif ismember(hObj, EigenFilterSizeSlider)
						textTarget = EigenFilterSizeEdit(colPos);
					elseif ismember(hObj, MinFASTQualitySlider)
						textTarget = MinFASTQualityEdit(colPos);
					elseif ismember(hObj, MinFASTContrastSlider)
						textTarget = MinFASTContrastEdit(colPos);
					elseif ismember(hObj, MinBRISKQualitySlider)
						textTarget = MinBRISKQualityEdit(colPos);
					elseif ismember(hObj, minBRISKContrastSlider)
						textTarget = minBRISKContrastEdit(colPos);
					end
					set(textTarget, ...
						'string', sprintf(fmt, get(hObj, 'Value')));
					drawnow;
				end
			end
		end
		%
		selectedFeatureType = get(get(featureTypeBG, 'SelectedObject'), 'tag');
		selectedExtractorType = get(get(extractorTypeBG, 'SelectedObject'), 'tag');
		if hObj == featureTypeBG
			set(FTPanels, 'visible', 'off');
			set(findobj(featureBasedImageRegistrationParent, ...
				'tag', [selectedFeatureType 'Panel']), 'visible', 'on');
			resetImrects
		end
		if strcmp(selectedExtractorType, 'HOG')
			set(ExtractorTypeOptsPanel1, 'visible', 'off')
			set(HOGProps, 'visible', 'on')
			set(findall(featureBasedImageRegistrationParent, ...
				'tag', 'HOGAnnotation'), 'visible', 'on')
		else
			set(HOGProps, 'visible', 'off')
			set(ExtractorTypeOptsPanel1, 'visible', 'on')
			set(findall(featureBasedImageRegistrationParent, 'tag', 'HOGAnnotation'), 'visible', 'off')
		end
		if ~suppressUpdate
			CVOperation
		end
	end %updateUIControl
end
% END NESTED FUNCTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% START (NON-NESTED) SUBFUNCTIONS %%%%%%%%%%%%%%%%%%%%%%%
function [objpos, objdim] = distributeObjects(nobjects, startpos, endpos, gap, warnoff)
%[objpos, objdim] = distributeObjects(nobjects, startpos, endpos, gap, warnoff)
%
%Returns the proper positions and size for uniformly spaced GUI objects.
%
%Enter the number of objects (nobjects), the starting position (startpos), 
%the end position (endpos), and the gap, and this function will return a
%vector of starting points (objpos) as well as a dimension for all
%uniformly sized, equally spaced objects (buttons, boxes, etc.).
%
%This works for horizontal OR vertical distribution of items, as long as
%startpos < endpos, and for normalized or any other kind of unit .
%
% E.g., To uniformly distributeObjects 4 buttons horizontally starting at 10
% pixels, ending at 100 pixels, and with a gap of 5 pixels, 
% [objpos, objdim] = distributeObjects(4, 10, 100, 5) returns
% objpos = [100 33.7500 57.5000 81.2500], 
% objdim = 18.7500
% Thus, your GUI buttons should be positioned at
% [objpos(1) y objdim height], [objpos(2) y objdim height], ....
%
%Written by Brett Shoelson
%12/09/03
%shoelson@helix.nih.gov

if nargin<5
	warnoff = 0;
end

rev = 0;
if startpos > endpos
	rev = 1;
	tmp = endpos;
	endpos = startpos;
	startpos = tmp;
end

objdim = ((endpos-startpos)-(nobjects-1)*gap)/nobjects;
objpos = startpos:objdim+gap:endpos;
%Account for case of gap==0, which generates a starting point at the end of
%the object range.
objpos = objpos(1:nobjects);

if rev
	objpos = objpos(end:-1:1);
end
if ~warnoff && (any(objpos < 0) || objdim < 0)
	warndlg('The parameters you entered result in a negative starting point or dimension. You may want to rethink that.');
end

end %distributeObjects

function k = isodd(x)
k = rem(x, 2) ~= 0;
end %isodd
% END (NON-NESTED) SUBFUNCTIONS %%%%%%%%%%%%%%%%%%%%%%%%
